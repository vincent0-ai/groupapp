{% extends "base.html" %}

{% block title %}Whiteboard - Discussio{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.2.0/dist/livekit-client.umd.min.js"></script>
<style>
    canvas {
        border: 2px solid var(--border-color);
        background: #fff;
        cursor: crosshair;
        border-radius: 8px;
        touch-action: none;
    }

    .controls {
        margin-bottom: 15px;
    }

    /* Fullscreen mode styles */
    .whiteboard-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        background: #fff !important;
        border-radius: 0 !important;
        border: none !important;
    }

    /* When the whiteboard container is fullscreen, ensure the canvas actually
       fills the viewport (overrides inline height:50vh) so on mobile the draw
       area covers the entire screen height. */
    .whiteboard-fullscreen canvas {
        width: 100vw !important;
        height: 100vh !important;
        max-height: 100vh !important;
        display: block !important;
    }

    .fullscreen-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        display: flex;
        gap: 10px;
        background: rgba(255,255,255,0.95);
        padding: 10px 15px;
        border-radius: 30px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .fullscreen-controls button {
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .fullscreen-exit-btn {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10000;
        border-radius: 50%;
        width: 45px;
        height: 45px;
    }

    /* Participant list improvements */
    #participantsList .participants-row {
        align-items: center;
        justify-content: space-between;
    }

    #participantsList .participant-name {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    #participantsList .mod-btn {
        padding: 6px 8px;
        font-size: 0.85rem;
        border-radius: 8px;
    }

    /* Always show fullscreen toggle (desktop & mobile) */
    .fullscreen-toggle-btn {
        display: inline-flex !important;
    }

    /* Mobile Controls Bar */
    @media (max-width: 991px) {
        #sessionControls {
            position: fixed;
            top: 56px; /* Approximate navbar height */
            left: 0;
            width: 100%;
            z-index: 1020;
            background: white;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-bottom: 1px solid var(--border-color);
            /* keep controls on a single horizontal line and allow scrolling */
            flex-wrap: nowrap !important;
            overflow-x: auto;
            justify-content: flex-start;
            border-radius: 0 !important;
            border: none !important;
            border-bottom: 1px solid var(--border-color) !important;
        }
        
        #sessionControls::-webkit-scrollbar {
            display: none;
        }
        
        #sessionView {
            margin-top: 60px !important;
        }

        /* Prevent buttons from wrapping into vertical / stacked text on certain mobile browsers */
        #sessionControls, #sessionControls * {
            -webkit-overflow-scrolling: touch;
            white-space: nowrap !important;
            writing-mode: horizontal-tb !important;
        }

        #sessionControls .btn {
            flex: 0 0 auto !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 6px;
        }

        /* When the whiteboard is fullscreen we hide the floating controls in
           favor of the fullscreen controls to avoid obscuring the canvas. */
        .whiteboard-fullscreen ~ #sessionControls,
        .whiteboard-fullscreen + #sessionControls {
            display: none !important;
        }

        /* Compact icon-only mode for very narrow screens */
        @media (max-width: 420px) {
            #sessionControls {
                padding: 8px 10px;
            }
            #sessionControls .btn {
                padding: 0 !important;
                width: 44px !important;
                height: 44px !important;
                border-radius: 50% !important;
                justify-content: center !important;
                font-size: 0; /* hide stray text nodes if any */
            }
            #sessionControls .btn .btn-text { display: none !important; }
            #sessionControls .btn i { font-size: 1.05rem !important; }
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header mb-4" style="background: var(--gradient-primary); border-radius: 20px; padding: 2rem; color: white;">
    <div class="d-flex align-items-center gap-3">
        <div>
            <h1 class="mb-1" style="font-size: 1.75rem; font-weight: 700;">Collaborate</h1>
            <p class="mb-0 opacity-75">Draw and collaborate in real-time with your group</p>
        </div>
    </div>
</div>

<!-- Landing View -->
<div id="landingView" style="display:none;">
    <div class="row mt-4">
        <div class="col-md-8 offset-md-2">
            <div class="card shadow-sm border-0 mb-4" style="overflow: hidden;">
                <div class="card-body text-center p-5" style="background: var(--primary-ultra-light);">
                    <p class="text-muted mb-4">Create a new whiteboard session or join an existing one</p>
                    <div class="d-flex justify-content-center gap-3 flex-wrap">
                        <button id="createSessionBtnLanding" class="btn btn-primary btn-lg px-4">
                            <i class="fas fa-plus-circle me-2"></i> Create Session
                        </button>
                        <button id="joinSessionBtnLanding" class="btn btn-outline-primary btn-lg px-4">
                            <i class="fas fa-sign-in-alt me-2"></i> Join Session
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="card shadow-sm border-0" id="mySessionsCardLanding" style="display:none;">
                <div class="card-header" style="background: transparent; border-bottom: 1px solid var(--border-color);">
                    <h5 class="mb-0"><i class="fas fa-list text-primary me-2"></i> My Active Sessions</h5>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush" id="mySessionsListLanding">
                        <!-- Sessions will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Session View -->
<div id="sessionView" class="row mt-4" style="display:none;">
    <!-- Top Controls Bar -->
    <div class="col-12 mb-3">
        <div id="sessionControls" class="d-flex flex-wrap gap-2 align-items-center p-3 bg-white rounded shadow-sm border"></div>
    </div>

    <div class="col-lg-2">
        <div class="card shadow-sm border-0 mb-3" style="overflow: hidden;">
            <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="card-title mb-0 fw-semibold"><i class="fas fa-paint-brush text-primary me-2"></i>Tools</h6>
                        <button class="btn btn-sm btn-outline-primary" data-bs-toggle="collapse" data-bs-target="#drawingToolsCollapse" aria-expanded="false" aria-controls="drawingToolsCollapse" id="toggleDrawingTools" style="font-size: 0.75rem;">Show</button>
                    </div>
                    <div id="permissionStatus" class="mb-2 text-muted small mt-2"></div>
                    <div class="collapse" id="drawingToolsCollapse">
                        <div class="controls mb-3 mt-3">
                            <label for="colorPicker" class="form-label small fw-medium">Color</label>
                            <input type="color" class="form-control form-control-color w-100" id="colorPicker" value="#000000" style="height: 40px; border-radius: 10px;">
                        </div>
                        <div class="controls mb-3">
                            <label for="brushSize" class="form-label small fw-medium">Brush Size: <span id="sizeValue" class="badge bg-primary">3</span>px</label>
                            <input type="range" class="form-range" id="brushSize" min="1" max="20" value="3">
                        </div>
                        <div class="controls mb-3">
                            <label for="opacity" class="form-label small fw-medium">Opacity</label>
                            <input type="range" class="form-range" id="opacity" min="0" max="1" step="0.1" value="1">
                        </div>
                        <div class="btn-group-vertical w-100 gap-2">
                            <button id="clearBtn" class="btn btn-warning">
                                <i class="fas fa-trash me-1"></i> Clear
                            </button>
                            <button id="undoBtn" class="btn btn-outline-secondary">
                                <i class="fas fa-undo me-1"></i> Undo
                            </button>
                            <button id="downloadBtn" class="btn btn-info text-white">
                                <i class="fas fa-download me-1"></i> Save
                            </button>
                        </div>
                    </div>
            </div>
        </div>

        <div class="card mt-3 shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header" style="background: rgba(79, 70, 229, 0.08); border-bottom: none;">
                <h6 class="mb-0 fw-semibold"><i class="fas fa-users text-primary me-2"></i> Participants</h6>
            </div>
            <div class="card-body">
                <div id="participantsList" style="max-height: 30vh; overflow-y: auto;">
                    <small class="text-body-secondary">Connecting...</small>
                </div>
                <div id="inviteLinkContainer" class="mt-3 border-top pt-2"></div>
                <div id="audioFilesContainer" class="mt-3 border-top pt-2"></div>
            </div>
        </div>
    </div>

    <div class="col-lg-10">
        <div class="card shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header d-flex justify-content-between align-items-center" style="background: rgba(79, 70, 229, 0.08); border-bottom: none;">
                <span class="fw-semibold"><i class="fas fa-chalkboard text-primary me-2"></i>Whiteboard</span>
                <button id="fullscreenToggleBtn" class="btn btn-sm btn-primary fullscreen-toggle-btn">
                    <i class="fas fa-expand me-1"></i> Fullscreen
                </button>
            </div>
            <div class="card-body overflow-auto text-center" id="canvasContainer" style="background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%); padding: 1rem;">
                <div style="position:relative; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <canvas id="whiteboard" style="width:100%;height:50vh;display:block; background: white;" width="1200" height="600"></canvas>
                    
                    <!-- FIX: Replaced blur with a non-intrusive View Only badge -->
                    <div id="canvasOverlay" style="position:absolute; top: 12px; right: 12px; display:none; pointer-events: none; z-index: 10;">
                        <span class="badge bg-secondary shadow-sm"><i class="fas fa-eye me-1"></i> View Only</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Remote Video Container (Screen Share) -->
<div id="remoteVideoContainer" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; flex-direction: column;">
    <div class="d-flex w-100 justify-content-end p-3" style="position: absolute; top: 0; right: 0;">
        <button id="fullscreenBtn" class="btn btn-outline-light rounded-circle me-2" title="Toggle Fullscreen"><i class="fas fa-expand"></i></button>
        <button class="btn btn-outline-light rounded-circle" onclick="document.getElementById('remoteVideoContainer').style.display='none'" title="Close Video"><i class="fas fa-times"></i></button>
    </div>
    <video id="remoteVideo" autoplay playsinline controls style="max-width: 95%; max-height: 90%; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></video>
    <div id="remoteVideoLabel" class="text-white mt-2 fw-bold fs-5"></div>
</div>
{% endblock %}

{% block modals %}
<!-- Create/Join Session Modals -->
<!-- Create Session Modal -->
<div class="modal fade" id="createSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-plus-circle me-2"></i>Create Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="text-muted mb-3">Select which group this session is for:</p>
                <div class="mb-3">
                    <label for="sessionGroupSelect" class="form-label fw-medium">Group</label>
                    <select id="sessionGroupSelect" class="form-select" style="border-radius: 10px;"></select>
                </div>
                <div class="mb-3">
                    <label for="sessionNameInput" class="form-label fw-medium">Session Name</label>
                    <input type="text" class="form-control" id="sessionNameInput" placeholder="Enter session name (optional)" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="createSessionSubmit" type="button" class="btn btn-primary">Create Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Session Created Modal -->
<div class="modal fade" id="sessionCreatedModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-success); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-check-circle me-2"></i>Session Created</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="mb-3">Share this link with your group members:</p>
                <div class="input-group">
                    <input type="text" class="form-control" id="createdSessionLink" readonly style="border-radius: 10px 0 0 10px;">
                    <button class="btn btn-primary" type="button" onclick="navigator.clipboard.writeText(document.getElementById('createdSessionLink').value); this.innerHTML='<i class=\'fas fa-check\'></i>'; setTimeout(()=>this.innerHTML='<i class=\'fas fa-copy\'></i>', 2000);" style="border-radius: 0 10px 10px 0;"><i class="fas fa-copy"></i></button>
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
                <button id="goToSessionBtn" type="button" class="btn btn-primary"><i class="fas fa-arrow-right me-1"></i>Go to Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Join Session Modal -->
<div class="modal fade" id="joinSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-sign-in-alt me-2"></i>Join Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <div class="mb-3">
                    <label class="form-label fw-medium">Session ID</label>
                    <input id="joinSessionId" class="form-control" placeholder="Enter session ID or paste invite link" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="joinSessionSubmit" type="button" class="btn btn-primary"><i class="fas fa-sign-in-alt me-1"></i>Join</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    (() => {
        const token = localStorage.getItem('token');
        const userId = localStorage.getItem('userId');

        if (!token || !userId) {
            sessionStorage.setItem('redirectAfterLogin', window.location.href);
            window.location.href = "{{ url_for('auth_page') }}";
            return;
        }

        // --- DOM Elements ---
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const sessionId = new URLSearchParams(window.location.search).get('session');
        const participantsEl = document.getElementById('participantsList');
        const landingView = document.getElementById('landingView');
        const sessionView = document.getElementById('sessionView');
        const controlsContainer = document.getElementById('sessionControls');
        const remoteVideoContainer = document.getElementById('remoteVideoContainer');
        const remoteVideoEl = document.getElementById('remoteVideo');
        const remoteVideoLabel = document.getElementById('remoteVideoLabel');
        const participantsAudioContainer = document.createElement('div');
        participantsAudioContainer.id = 'participantsAudioContainer';
        // We do NOT hide this with display:none because some browsers won't play audio from hidden elements.
        // Instead we make it size 0/0.
        participantsAudioContainer.style.width = '0px';
        participantsAudioContainer.style.height = '0px';
        participantsAudioContainer.style.overflow = 'hidden';
        document.body.appendChild(participantsAudioContainer);

        // Detect whether screen sharing is supported by the browser/device.
        const supportsDisplayMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
        // Map to hold AudioContext source/gain nodes for remote audio fallbacks
        const remoteAudioNodes = new Map();

        // FIX: Local history for resizing
        let drawHistory = [];
        // Quick mode: eraser toggle when true
        let isErasing = false;

        // --- LiveKit Service ---
        class MediaService {
            constructor() {
                this.room = null;
                this.onTrackSubscribed = null;
                this.onTrackUnsubscribed = null;
                this.onParticipantDisconnected = null;
                this.onConnectionStateChange = null;
            }

            async connect(token, url) {
                this.room = new LivekitClient.Room({
                    audioCaptureDefaults: {
                        autoGainControl: true,
                        echoCancellation: true,
                        noiseSuppression: true,
                        channelCount: 1, // Mono audio
                    },
                    videoCaptureDefaults: {
                        resolution: LivekitClient.VideoPresets.h720.resolution,
                    },
                    publishDefaults: {
                        audioBitrate: 20000, // 20kbps
                        videoCodec: 'vp8',
                        simulcast: false, // Disabled for free tier
                        videoEncoding: { maxBitrate: 1_500_000, maxFramerate: 30 },
                    },
                    adaptiveStream: true,
                    dynacast: true,
                });

                await this.room.connect(url, token);

                this.room
                    .on(LivekitClient.RoomEvent.TrackSubscribed, (t, p, participant) => this.onTrackSubscribed?.(t, participant))
                    .on(LivekitClient.RoomEvent.TrackUnsubscribed, (t, p, participant) => this.onTrackUnsubscribed?.(t, participant))
                    .on(LivekitClient.RoomEvent.ParticipantDisconnected, (p) => this.onParticipantDisconnected?.(p))
                    .on(LivekitClient.RoomEvent.ConnectionStateChanged, (state) => this.onConnectionStateChange?.(state));
                
                console.log('Connected to LiveKit room:', this.room.name);

                // FIX: Ensure audio system is primed
                try {
                    await primeAudio();
                } catch (e) { /* ignore */ }

                try {
                    // FIX: Iterate over existing participants and their track publications
                    // This fixes the issue where you can't hear people who joined *before* you.
                    if (this.room && this.room.participants) {
                        for (const participant of this.room.participants.values()) {
                            // Check track publications
                            const publications = participant.getTracks();
                            publications.forEach(pub => {
                                if (pub && pub.track) {
                                    this.onTrackSubscribed?.(pub.track, participant);
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.debug('Failed to process existing participant tracks', e);
                }

                return this.room;
            }

            async disconnect() {
                if (this.room) {
                    await this.room.disconnect();
                    this.room = null;
                    console.log('Disconnected from LiveKit room.');
                }
            }

            async publishAudio(enabled) {
                if (!this.room?.localParticipant) return;
                try {
                    const res = await this.room.localParticipant.setMicrophoneEnabled(enabled);
                    return res;
                } catch (e) {
                    console.error('[MediaService] publishAudio failed ->', e);
                    throw e;
                }
            }

            async publishScreenShare(enabled) {
                if (!this.room?.localParticipant) return;
                const screenShareOpts = { audio: false, selfBrowserSurface: "include" };
                return await this.room.localParticipant.setScreenShareEnabled(enabled, screenShareOpts);
            }
        }
        const mediaService = new MediaService();

        // --- Application State ---
        let isDrawing = false, lastX = 0, lastY = 0;
        let participants = {}, isCreator = false;
        let canDraw = true, canSpeak = true, canShareScreen = true;
        let isInCall = false, isMuted = false, isScreenSharing = false;
        // Track when a moderator forced a mute so we can allow auto-unmute when permission is restored
        let mutedByModerator = false;
        const socket = io();

        // --- Media Call Logic ---
        function setupMediaControls() {
            if (!sessionId || document.getElementById('liveBtn')) return;
            const liveBtn = document.createElement('button');
            liveBtn.id = 'liveBtn';
            liveBtn.className = 'btn btn-sm btn-outline-success';
            liveBtn.setAttribute('aria-label', 'Join Call');
            liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';

            const muteBtn = document.createElement('button');
            muteBtn.id = 'muteBtn';
            muteBtn.className = 'btn btn-sm btn-outline-warning';
            muteBtn.setAttribute('aria-label', 'Mute');
            muteBtn.disabled = true;
            muteBtn.innerHTML = '<i class="fas fa-microphone"></i><span class="btn-text"> Mute</span>';

            const screenShareBtn = document.createElement('button');
            screenShareBtn.id = 'screenShareBtn';
            screenShareBtn.className = 'btn btn-sm btn-outline-info';
            screenShareBtn.setAttribute('aria-label', 'Share Screen');
            screenShareBtn.disabled = true;
            screenShareBtn.innerHTML = '<i class="fas fa-desktop"></i><span class="btn-text"> Share Screen</span>';
            if (!supportsDisplayMedia) {
                screenShareBtn.disabled = true;
                screenShareBtn.title = 'Screen sharing not supported on this device or browser';
            }
            
            const watchScreenBtn = document.createElement('button');
            watchScreenBtn.id = 'watchScreenBtn';
            watchScreenBtn.className = 'btn btn-sm btn-outline-primary';
            watchScreenBtn.setAttribute('aria-label', 'Watch Screen');
            watchScreenBtn.disabled = true;
            watchScreenBtn.innerHTML = '<i class="fas fa-eye"></i><span class="btn-text"> Watch Screen</span>';

            const raiseBtn = document.createElement('button');
            raiseBtn.id = 'raiseBtn';
            raiseBtn.className = 'btn btn-sm btn-outline-secondary';
            raiseBtn.setAttribute('aria-label', 'Raise Hand');
            raiseBtn.innerHTML = '<i class="fas fa-hand-paper"></i><span class="btn-text"> Raise Hand</span>';

            const leaveSessionBtn = document.createElement('button');
            leaveSessionBtn.id = 'leaveSessionBtn';
            leaveSessionBtn.className = 'btn btn-sm btn-outline-danger';
            leaveSessionBtn.setAttribute('aria-label', 'Leave Session');
            leaveSessionBtn.innerHTML = '<i class="fas fa-sign-out-alt me-1"></i><span class="btn-text"> Leave</span>';


            controlsContainer.appendChild(liveBtn);
            controlsContainer.appendChild(muteBtn);
            controlsContainer.appendChild(screenShareBtn);
            controlsContainer.appendChild(watchScreenBtn);
            controlsContainer.appendChild(raiseBtn);
            controlsContainer.appendChild(leaveSessionBtn);

            watchScreenBtn.addEventListener('click', async () => {
                const remoteContainer = document.getElementById('remoteVideoContainer');
                if (!remoteContainer || remoteContainer.style.display === 'none') return showCustomAlert('No active screen share to watch.', 'Screen Share');
                try {
                    if (document.fullscreenElement && document.fullscreenElement !== remoteContainer) await document.exitFullscreen();
                    await remoteContainer.requestFullscreen();
                } catch (e) {
                    remoteContainer.classList.toggle('whiteboard-fullscreen');
                }
            });
            liveBtn.addEventListener('click', () => isInCall ? leaveCall() : joinCall());
            muteBtn.addEventListener('click', async () => {
                if (!isInCall) return showCustomAlert('Join the call first to toggle microphone.', 'Not In Call');
                if (isMuted) {
                    if (!canSpeak) {
                        showCustomAlert('You have been muted by the moderator.', 'Muted');
                        return;
                    }
                }
                isMuted = !isMuted;
                try { await mediaService.publishAudio(!isMuted); } catch (e) { console.error('Failed to toggle audio', e); }
                if (!isMuted) mutedByModerator = false;
                updateMuteButton();
            });
            screenShareBtn.addEventListener('click', async () => {
                if (!isInCall) return showCustomAlert('Join the call first to share your screen.', 'Not In Call');
                if (!supportsDisplayMedia) return showCustomAlert('Screen sharing is not supported by your browser.', 'Screen Share');
                if (!canShareScreen) return showCustomAlert('You do not have permission to share your screen.', 'Permission');
                isScreenSharing = !isScreenSharing;
                try {
                    await mediaService.publishScreenShare(isScreenSharing);
                } catch(e) {
                     console.error('Screen share failed:', e);
                     isScreenSharing = false;
                     showCustomAlert('Could not start screen sharing.', 'Screen Share');
                }
                updateScreenShareButton();
            });
            raiseBtn.addEventListener('click', () => {
                 socket.emit('raise_hand', { room: `whiteboard:${sessionId}`, user_id: userId });
                 if(participants[userId]) participants[userId].raised = true;
                 renderParticipants();
            });

            try { document.getElementById('leaveSessionContainer').style.display = 'none'; } catch(e){}

            leaveSessionBtn.addEventListener('click', async () => {
                if (isCreator) {
                    if (!confirm('End session for everyone?')) return;
                    await endSession(sessionId);
                    return;
                }
                try { await leaveCall(); } catch(e){}
                window.location.href = '/whiteboard';
            });
        }

        function updateMuteButton() {
            const muteBtn = document.getElementById('muteBtn');
            if(!muteBtn) return;
            muteBtn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i><span class="btn-text"> Unmute</span>' : '<i class="fas fa-microphone"></i><span class="btn-text"> Mute</span>';
            muteBtn.className = isMuted ? 'btn btn-sm btn-warning' : 'btn btn-sm btn-outline-warning';
            muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
            muteBtn.setAttribute('aria-pressed', String(!isMuted));
        }

        function updateScreenShareButton() {
            const screenShareBtn = document.getElementById('screenShareBtn');
            if(!screenShareBtn) return;
            screenShareBtn.innerHTML = isScreenSharing ? '<i class="fas fa-desktop"></i><span class="btn-text"> Stop Sharing</span>' : '<i class="fas fa-desktop"></i><span class="btn-text"> Share Screen</span>';
            screenShareBtn.className = isScreenSharing ? 'btn btn-sm btn-info text-white' : 'btn btn-sm btn-outline-info';
            screenShareBtn.disabled = !isInCall;
        }

        async function getLiveKitToken(lkSessionId) {
            try {
                const res = await fetch(`/api/whiteboards/${lkSessionId}/livekit-token`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const text = await res.text();
                let json = null;
                try { json = JSON.parse(text); } catch(e) { /* not JSON */ }
                if (!res.ok) {
                    throw new Error((json && (json.message || json.error)) || text || 'Failed to get media token');
                }
                return { token: json?.data?.token || json?.token, url: json?.data?.url || json?.url };
            } catch (e) {
                console.error('getLiveKitToken failed:', e);
                showCustomAlert(e.message, 'Media Server Error');
                return null;
            }
        }

        async function primeAudio() {
            try {
                if (window.__audioPrimed) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtx) return;
                const ctx = new AudioCtx();
                await ctx.resume();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                gain.gain.value = 0;
                osc.connect(gain).connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.01);
                window.__audioPrimed = true;
                window.__audioContext = ctx;
            } catch (e) {
                console.warn('Audio priming failed', e);
            }
        }

        async function joinCall() {
            const liveBtn = document.getElementById('liveBtn');
            if (!liveBtn) return;
            
            liveBtn.disabled = true;
            liveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span class="btn-text"> Joining...</span>';
            const lkResp = await getLiveKitToken(sessionId);
            if (!lkResp || !lkResp.token) {
                liveBtn.disabled = false;
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
                return;
            }

            const lkToken = lkResp.token;
            const configured = lkResp.url || "{{ config.LIVEKIT_URL }}" || "http://localhost:7880";
            const wsUrl = String(configured).replace(/^http/, 'ws');

            try {
                await primeAudio();
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (permErr) {
                    console.warn('Microphone permission denied', permErr);
                    showCustomAlert('Microphone access was denied. You will join muted.', 'Permission');
                }
                
                await mediaService.connect(lkToken, wsUrl);
                isInCall = true;

                liveBtn.disabled = false;
                liveBtn.className = 'btn btn-sm btn-danger';
                liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i><span class="btn-text"> Leave</span>';

                if (canSpeak) {
                    isMuted = false;
                    try { await mediaService.publishAudio(true); } catch(e) { console.warn('Auto-enable mic failed', e); }
                } else {
                    isMuted = false; 
                    try { await mediaService.publishAudio(true); } catch(e) { }
                }
                updateMuteButton();

            } catch (e) {
                console.error('Failed to join LiveKit call:', e);
                showCustomAlert('Could not connect to the media session.', 'Connection Error');
                isInCall = false;
                liveBtn.disabled = false;
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
            }
        }

        async function leaveCall() {
            await mediaService.disconnect();
            isInCall = false;
            isScreenSharing = false;

            const liveBtn = document.getElementById('liveBtn');
            if(liveBtn) {
                liveBtn.className = 'btn btn-sm btn-outline-success';
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
            }
            const muteBtn = document.getElementById('muteBtn');
            const screenShareBtn = document.getElementById('screenShareBtn');
            if (muteBtn) { muteBtn.disabled = true; }
            if (screenShareBtn) { screenShareBtn.disabled = true; }
            
            remoteVideoContainer.style.display = 'none';
            try { document.getElementById('watchScreenBtn')?.setAttribute('disabled', 'true'); } catch(e){}
            if(remoteVideoEl) remoteVideoEl.srcObject = null;
            participantsAudioContainer.innerHTML = '';
        }

        mediaService.onTrackSubscribed = (track, participant) => {
            if (track.kind === 'video') {
                remoteVideoContainer.style.display = 'flex';
                try {
                    track.attach(remoteVideoEl);
                    remoteVideoEl.muted = false;
                    remoteVideoEl.controls = true;
                    remoteVideoEl.autoplay = true;
                    remoteVideoLabel.textContent = `${participant.name || participant.identity}'s screen`;
                } catch (e) {
                    const el = track.attach();
                    remoteVideoEl.replaceChildren(el);
                    remoteVideoLabel.textContent = `${participant.name || participant.identity}'s screen`;
                }
                try { document.getElementById('watchScreenBtn')?.removeAttribute('disabled'); } catch(e){}
                
            } else if (track.kind === 'audio') {
                console.debug('[Media] audio track subscribed from', participant.identity);
                // FIX: Attach to the hidden participants audio container to avoid leaving orphaned
                // audio elements directly on the document body (helps on reconnects and cleanup).
                const el = track.attach();
                el.id = `audio-${participant.identity}`;
                el.autoplay = true;
                el.playsInline = true;
                // Ensure small footprint and append to our dedicated container
                try { participantsAudioContainer.appendChild(el); } catch (e) { document.body.appendChild(el); }
                
                // Aggressive play attempt for mobile
                const attemptPlay = async () => {
                    try {
                        el.muted = false;
                        await el.play();
                    } catch (err) {
                        console.warn('Audio play blocked, attempting fallback', err);
                        // If blocked, prime and try again
                        if (window.__audioContext && window.__audioContext.state === 'suspended') {
                            try { await window.__audioContext.resume(); } catch(e) {}
                            try { await el.play(); } catch(e) {}
                        }
                    }
                };
                attemptPlay();
            }
        };

        mediaService.onTrackUnsubscribed = (track, participant) => {
            if (track.kind === 'video') {
                if (remoteVideoEl) {
                    try {
                        remoteVideoEl.pause();
                        remoteVideoEl.srcObject = null;
                        remoteVideoEl.replaceChildren();
                    } catch (e) { }
                }
                remoteVideoContainer.style.display = 'none';
                remoteVideoLabel.textContent = '';
                try { document.getElementById('watchScreenBtn')?.setAttribute('disabled', 'true'); } catch(e){}
            }
            track.detach().forEach(el => el.remove());
            const specificEl = document.getElementById(`audio-${participant.identity}`);
            if (specificEl) specificEl.remove();
        };

        mediaService.onParticipantDisconnected = (participant) => {
            document.getElementById(`audio-${participant.identity}`)?.remove();
        };
        
        mediaService.onConnectionStateChange = (state) => {
            if (state === LivekitClient.ConnectionState.Disconnected) {
                if (isInCall) {
                    leaveCall();
                    showCustomAlert('You have been disconnected from the media session.', 'Disconnected');
                }
            }
        };

        // --- Init and Socket Handlers ---
        
        if (sessionId) {
            landingView.style.display = 'none';
            sessionView.style.display = 'flex';
            setupMediaControls();
        } else {
            landingView.style.display = 'block';
            sessionView.style.display = 'none';
            try { loadMySessions(); } catch(e) { console.warn('loadMySessions unavailable yet'); }
        }
        
        async function loadSessionInfo() {
             if (!sessionId) return;
            try {
                const res = await fetch(`/api/whiteboards/${sessionId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (res.status >= 400) {
                    await showCustomAlert((await res.json()).message || 'Session not found', 'Error');
                    window.location.href = '/whiteboard';
                    return;
                }
                const data = await res.json();
                const wb = data.data;

                if (wb.title) {
                    document.querySelector('h1').textContent = wb.title;
                    document.title = `${wb.title} - Discussio`;
                }

                isCreator = wb.created_by === userId;
                const leaveBtn = document.getElementById('leaveSessionBtn');
                if (leaveBtn) {
                    if (isCreator) {
                        leaveBtn.setAttribute('aria-label', 'End Session');
                        leaveBtn.innerHTML = '<i class="fas fa-stop-circle me-1"></i><span class="btn-text"> End Session</span>';
                        leaveBtn.className = 'btn btn-sm btn-danger';
                        leaveBtn.onclick = async () => { if (confirm('End session for everyone?')) await endSession(sessionId); };
                    } else {
                        leaveBtn.setAttribute('aria-label', 'Leave');
                        leaveBtn.innerHTML = '<i class="fas fa-sign-out-alt me-1"></i><span class="btn-text"> Leave</span>';
                        leaveBtn.className = 'btn btn-sm btn-outline-danger';
                        leaveBtn.onclick = async () => { try { await leaveCall(); } catch(e){}; window.location.href = '/whiteboard'; };
                    }
                }

                participants = (wb.participants || []).reduce((acc, p) => {
                    const uid = p.id || p._id;
                    acc[uid] = { name: p.username || p.full_name || `User ${String(uid).substr(-4)}`, avatar_url: p.avatar_url || '', can_draw: (wb.can_draw || []).map(String).includes(String(uid)), can_speak: (wb.can_speak || []).map(String).includes(String(uid)), can_share_screen: (wb.can_share_screen || []).map(String).includes(String(uid)) };
                    return acc;
                }, {});
                
                canDraw = isCreator || (wb.can_draw || []).map(String).includes(userId);
                canSpeak = isCreator || (wb.can_speak || []).map(String).includes(userId);
                canShareScreen = isCreator || (wb.can_share_screen || []).map(String).includes(userId);

                updatePermissionUI();
                renderParticipants();

                // FIX: Populate Draw History locally
                if (wb.drawing_data) {
                    drawHistory = wb.drawing_data;
                    redrawHistory();
                }
            } catch (e) { console.error('Failed to fetch session info', e); }
        }

        function renderParticipants() {
            if(!participantsEl) return;
            const content = Object.entries(participants).map(([uid, meta]) => {
                const avatarSrc = meta.avatar_url || `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(meta.name || uid)}`;
                let moderatorControls = '';
                if(isCreator && uid !== userId) {
                   moderatorControls = `
                    <button class="btn btn-xs mod-btn ${meta.can_draw ? 'btn-primary' : 'btn-outline-primary'}" data-action="${meta.can_draw ? 'revoke_draw' : 'grant_draw'}" data-uid="${uid}" title="${meta.can_draw ? 'Revoke' : 'Grant'} Draw"><i class="fas fa-pencil-alt"></i></button>
                    <button class="btn btn-xs mod-btn ${meta.can_speak ? 'btn-success' : 'btn-outline-secondary'}" data-action="${meta.can_speak ? 'revoke_speak' : 'grant_speak'}" data-uid="${uid}" title="${meta.can_speak ? 'Revoke' : 'Grant'} Speak"><i class="fas fa-microphone"></i></button>
                    <button class="btn btn-xs mod-btn ${meta.can_share_screen ? 'btn-info' : 'btn-outline-info'}" data-action="${meta.can_share_screen ? 'revoke_screen_share' : 'grant_screen_share'}" data-uid="${uid}" title="${meta.can_share_screen ? 'Revoke' : 'Grant'} Screen Share"><i class="fas fa-desktop"></i></button>
                    ${meta.raised ? `<button class="btn btn-xs mod-btn btn-outline-danger" data-action="clear_hand" data-uid="${uid}" title="Clear Hand"><i class="fas fa-hand-paper"></i></button>` : ''}
                `;
                } else {
                    moderatorControls = `<small class="text-muted">${meta.can_draw ? '✏️' : ''} ${meta.raised ? '✋' : ''}</small>`;
                }
                
                return `
                    <div class="participants-row d-flex align-items-center justify-content-between mb-2">
                        <div class="d-flex align-items-center min-width-0">
                            <img src="${avatarSrc}" class="rounded-circle me-2 flex-shrink-0" width="28" height="28"/>
                            <div class="participant-name small fw-medium text-truncate" title="${meta.name || uid}">${meta.name || uid}</div>
                        </div>
                        <div class="d-flex gap-1 align-items-center flex-shrink-0 moderator-controls">${moderatorControls}</div>
                    </div>`;
            }).join('');
            participantsEl.innerHTML = content;
            
            participantsEl.querySelectorAll('.mod-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = btn.dataset.action;
                    const targetId = btn.dataset.uid;
                    if (!action || !targetId) return;
                    const payload = { room: `whiteboard:${sessionId}`, user_id: targetId, requester_id: userId };
                    
                    try {
                        if (action === 'grant_draw') participants[targetId].can_draw = true;
                        if (action === 'revoke_draw') participants[targetId].can_draw = false;
                        if (action === 'grant_speak') participants[targetId].can_speak = true;
                        if (action === 'revoke_speak') participants[targetId].can_speak = false;
                        if (action === 'grant_screen_share') participants[targetId].can_share_screen = true;
                        if (action === 'revoke_screen_share') participants[targetId].can_share_screen = false;
                        renderParticipants();
                    } catch (e) { }

                    btn.disabled = true;
                    const prevHtml = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    if (action === 'clear_hand') {
                        socket.emit(action, { room: `whiteboard:${sessionId}`, user_id: targetId });
                    } else {
                        socket.emit(action, payload);
                    }

                    setTimeout(() => { try { btn.disabled = false; btn.innerHTML = prevHtml; } catch (e) {} }, 3000);
                });
            });
        }

        function updatePermissionUI() {
            if(!document.getElementById('permissionStatus')) return;
            const statusParts = [];
            statusParts.push(canDraw ? 'Draw: ✓' : 'Draw: ✕');
            statusParts.push(canSpeak ? 'Speak: ✓' : 'Speak: ✕');
            statusParts.push(canShareScreen ? 'Share: ✓' : 'Share: ✕');
            document.getElementById('permissionStatus').textContent = statusParts.join(' • ');
            
            // FIX: Removed logic that shows full screen overlay. Using Badge instead.
            // Also setting cursor to not-allowed.
            document.getElementById('canvasOverlay').style.display = canDraw ? 'none' : 'block';
            if(canvas) canvas.style.cursor = canDraw ? 'crosshair' : 'not-allowed';

            const muteBtn = document.getElementById('muteBtn');
            const screenShareBtn = document.getElementById('screenShareBtn');
            if (muteBtn) muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
            if (screenShareBtn) screenShareBtn.disabled = !isInCall || !canShareScreen || !supportsDisplayMedia;

            // Update fullscreen controls (if present)
            try {
                const fsClear = document.getElementById('wb-clear-btn');
                const fsUndo = document.getElementById('wb-undo-btn');
                const fsBrush = document.getElementById('wb-brush-toggle-btn');
                if (fsClear) fsClear.disabled = !canDraw;
                if (fsUndo) fsUndo.disabled = !canDraw || drawHistory.length === 0;
                if (fsBrush) fsBrush.disabled = !canDraw;
            } catch (e) { /* ignore */ }
        }
        
        socket.on('connect', () => socket.emit('join_room', { room: `whiteboard:${sessionId}`, user_id: userId }));
        socket.on('user_joined', (data) => {
            const p = data.profile;
            if (p && !participants[p.id]) {
                participants[p.id] = { name: p.full_name || p.username, avatar_url: p.avatar_url };
                renderParticipants();
            }
        });
        socket.on('user_left', (data) => {
            delete participants[data.user_id];
            renderParticipants();
        });
        socket.on('draw_update', (data) => {
            if (!data || !data.drawing_data) return;
            // FIX: Add to local history so we can redraw on resize
            drawHistory.push(data.drawing_data);
            
            const d = data.drawing_data;
            let x0 = d.x0, y0 = d.y0, x1 = d.x1, y1 = d.y1;
            if (d.normalized) {
                x0 = d.x0 * canvas.clientWidth;
                y0 = d.y0 * canvas.clientHeight;
                x1 = d.x1 * canvas.clientWidth;
                y1 = d.y1 * canvas.clientHeight;
            }
            draw(x0, y0, x1, y1, d.color, d.size, d.opacity);
        });
        socket.on('board_cleared', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // FIX: Clear history
            drawHistory = [];
        });

        // Handle undo actions from other participants (server emits for others)
        socket.on('undo_action', () => {
            if (!drawHistory.length) return;
            drawHistory.pop();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawHistory();
            try { if (!drawHistory.length) document.getElementById('wb-undo-btn')?.setAttribute('disabled', 'true'); } catch (e) {}
        });
        socket.on('session_ended', async (data) => {
            await leaveCall();
            showCustomAlert(data.reason || 'This session has been ended', 'Session Ended').then(() => window.location.href = '/whiteboard');
        });
        socket.on('session_warning', (data) => showCustomAlert(`This session will end in ${data.minutes_remaining} minutes.`, 'Session Warning'));
        
        socket.on('permissions_updated', (data) => {
            Object.keys(participants).forEach(uid => {
                participants[uid].can_draw = data.can_draw?.map(String).includes(String(uid));
                participants[uid].can_speak = data.can_speak?.map(String).includes(String(uid));
                participants[uid].can_share_screen = data.can_share_screen?.map(String).includes(String(uid));
            });
            canDraw = isCreator || data.can_draw?.map(String).includes(userId);
            canSpeak = isCreator || data.can_speak?.map(String).includes(userId);
            canShareScreen = isCreator || data.can_share_screen?.map(String).includes(userId);
            
            updatePermissionUI();
            
            if (isInCall) {
                const muteBtn = document.getElementById('muteBtn');
                if (muteBtn) muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
                
                if(!canSpeak && !isMuted) {
                    try { mediaService.publishAudio(false); } catch(e) { }
                    isMuted = true;
                    mutedByModerator = true;
                    updateMuteButton();
                }
                if (canSpeak && mutedByModerator && isMuted) {
                    try { mediaService.publishAudio(true).catch(() => {}); } catch (e) { }
                    isMuted = false;
                    mutedByModerator = false;
                    updateMuteButton();
                    try { showCustomAlert('Your microphone was unmuted.', 'Permission'); } catch(e){}
                }
                if(!canShareScreen && isScreenSharing) {
                    try { mediaService.publishScreenShare(false); } catch(e) { }
                    isScreenSharing = false;
                    updateScreenShareButton();
                }
            }
            renderParticipants();
        });

        socket.on('force_mute', (data) => {
            try {
                if (isInCall) {
                    mediaService.publishAudio(false).catch(() => {});
                    isMuted = true;
                    updateMuteButton();
                }
            } catch (e) { }
            try { showCustomAlert(data?.reason || 'You have been muted by the moderator.', 'Muted'); } catch(e){}
        });

        socket.on('force_stop_screen', (data) => {
            try {
                if (isInCall && isScreenSharing) {
                    mediaService.publishScreenShare(false).catch(() => {});
                    isScreenSharing = false;
                    updateScreenShareButton();
                }
            } catch (e) { }
            try { showCustomAlert(data?.reason || 'Screen sharing disabled by moderator.', 'Screen Share'); } catch(e){}
        });
        
        socket.on('hand_raised', (data) => {
            if(participants[data.user_id]) {
                participants[data.user_id].raised = true;
                renderParticipants();
            }
        });
        socket.on('hand_cleared', (data) => {
             if(participants[data.user_id]) {
                participants[data.user_id].raised = false;
                renderParticipants();
            }
        });

        // Simplified drawing logic
        // FIX: Added Debounce function to prevent lag on resize
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        const initDrawing = () => {
             if (!canvas) return;
            setCanvasSize();
            
            // FIX: Debounced resize listener that restores history
            window.addEventListener('resize', debounce(() => {
                setCanvasSize();
                redrawHistory();
            }, 200));

             if (document.getElementById('brushSize')) {
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    document.getElementById('sizeValue').textContent = e.target.value;
                });
            }
             canvas.addEventListener('mousedown', (e) => { if (canDraw) { isDrawing = true; const p = getPos(e.clientX, e.clientY); lastX = p.x; lastY = p.y; } });
             canvas.addEventListener('mousemove', (e) => { if (isDrawing && canDraw) { const p = getPos(e.clientX, e.clientY); draw(lastX, lastY, p.x, p.y); emitDraw(lastX, lastY, p.x, p.y); lastX = p.x; lastY = p.y; } });
             canvas.addEventListener('mouseup', () => isDrawing = false);
             canvas.addEventListener('mouseleave', () => isDrawing = false);
             canvas.addEventListener('touchstart', (e) => { if (canDraw) { e.preventDefault(); isDrawing = true; const t = e.touches[0]; const p = getPos(t.clientX, t.clientY); lastX = p.x; lastY = p.y; } }, { passive: false });
             canvas.addEventListener('touchmove', (e) => { if (isDrawing && canDraw) { e.preventDefault(); const t = e.touches[0]; const p = getPos(t.clientX, t.clientY); draw(lastX, lastY, p.x, p.y); emitDraw(lastX, lastY, p.x, p.y); lastX = p.x; lastY = p.y; } }, { passive: false });
             canvas.addEventListener('touchend', () => isDrawing = false);
             document.getElementById('clearBtn')?.addEventListener('click', () => {
                 if (confirm('Clear the entire whiteboard?')) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawHistory = [];
                    socket.emit('clear_board', { room: `whiteboard:${sessionId}`, user_id: userId });
                 }
             });
             // Undo button (sidebar)
             document.getElementById('undoBtn')?.addEventListener('click', () => undoLastStroke());
             // Optional brush toggle in sidebar (keeps parity with fullscreen toggle)
             // This just toggles eraser mode locally
             const sidebarBrushToggle = document.getElementById('brushToggleBtn');
             if (sidebarBrushToggle) {
                 sidebarBrushToggle.addEventListener('click', () => {
                     isErasing = !isErasing;
                     sidebarBrushToggle.innerHTML = isErasing ? '<i class="fas fa-eraser"></i> Erase' : '<i class="fas fa-paint-brush"></i> Brush';
                 });
             }
        };

        function getPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return { x: (clientX - rect.left), y: (clientY - rect.top) };
        }

        function setCanvasSize() {
            if (!canvas || !ctx) return;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const w = Math.round(rect.width * dpr);
            const h = Math.round(rect.height * dpr);
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }

        // FIX: New function to replay history on canvas
        function redrawHistory() {
            if (!ctx) return;
            if (!drawHistory.length) return;
            drawHistory.forEach(d => {
                let x0 = d.x0, y0 = d.y0, x1 = d.x1, y1 = d.y1;
                if (d.normalized) {
                    x0 = d.x0 * canvas.clientWidth;
                    y0 = d.y0 * canvas.clientHeight;
                    x1 = d.x1 * canvas.clientWidth;
                    y1 = d.y1 * canvas.clientHeight;
                }
                // Use draw with params from history; eraser entries may not be flagged specially,
                // erasing is implemented via client-side composite mode while drawing, so we just draw strokes.
                draw(x0, y0, x1, y1, d.color, d.size, d.opacity);
            });
        }

        // Undo the last stroke and notify others (unless silent)
        function undoLastStroke(emit = true) {
            if (!drawHistory.length) return;
            drawHistory.pop();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawHistory();
            if (emit && socket && sessionId) {
                socket.emit('undo_action', { room: `whiteboard:${sessionId}`, user_id: userId });
            }
            // Update undo button enabled state
            try { document.getElementById('wb-undo-btn')?.removeAttribute('disabled'); } catch (e) {}
        }

        function draw(x0, y0, x1, y1, color, size, opacity) {
            if (!ctx) return;
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = (typeof opacity === 'number') ? opacity : (document.getElementById('opacity')?.value || 1);
            const strokeColor = color || document.getElementById('colorPicker')?.value || '#000';
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = size || (document.getElementById('brushSize')?.value || 3);
            // If erasing mode is active, switch composite operation to remove pixels
            if (isErasing) {
                ctx.globalCompositeOperation = 'destination-out';
                // Ensure the stroke is solid to remove content cleanly
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                ctx.globalCompositeOperation = 'source-over';
            }
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }

        function emitDraw(x0, y0, x1, y1) {
            if (!socket || !sessionId) return;
            const color = document.getElementById('colorPicker')?.value || '#000';
            const size = parseInt(document.getElementById('brushSize')?.value || '3', 10);
            const opacity = parseFloat(document.getElementById('opacity')?.value || '1');
            const drawing_data = { x0: x0 / canvas.clientWidth, y0: y0 / canvas.clientHeight, x1: x1 / canvas.clientWidth, y1: y1 / canvas.clientHeight, color, size, opacity, normalized: true };
            
            // FIX: Add local stroke to history immediately
            drawHistory.push(drawing_data);
            
            // Enable undo button when new stroke added
            try { document.getElementById('wb-undo-btn')?.removeAttribute('disabled'); } catch (e) {}

            socket.emit('whiteboard_draw', { room: `whiteboard:${sessionId}`, drawing_data, user_id: userId });
        }
        
        initDrawing();
        loadSessionInfo();

        // --- Landing view: Create / Join session handlers ---
        const createSessionBtnLanding = document.getElementById('createSessionBtnLanding');
        const joinSessionBtnLanding = document.getElementById('joinSessionBtnLanding');
        const createSessionModalEl = document.getElementById('createSessionModal');
        const joinSessionModalEl = document.getElementById('joinSessionModal');
        const createSessionSubmit = document.getElementById('createSessionSubmit');
        const joinSessionSubmit = document.getElementById('joinSessionSubmit');
        const sessionGroupSelect = document.getElementById('sessionGroupSelect');
        const sessionNameInput = document.getElementById('sessionNameInput');
        const createdSessionLink = document.getElementById('createdSessionLink');
        const sessionCreatedModalEl = document.getElementById('sessionCreatedModal');
        const goToSessionBtn = document.getElementById('goToSessionBtn');

        async function populateGroupSelect() {
            if (!sessionGroupSelect) return;
            sessionGroupSelect.innerHTML = '<option value="">Loading groups...</option>';
            try {
                const res = await fetch('/api/groups', { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) throw new Error('Failed to load groups');
                const data = await res.json();
                const groups = (data.data && data.data.groups) || data.groups || [];
                sessionGroupSelect.innerHTML = '';
                const myGroups = groups.filter(g => g.is_member);
                if (myGroups.length === 0) {
                    sessionGroupSelect.innerHTML = '<option value="">No groups available</option>';
                    sessionGroupSelect.disabled = true;
                    createSessionSubmit.disabled = true;
                    return;
                }
                myGroups.forEach(g => {
                    const opt = document.createElement('option');
                    opt.value = g.id || g._id;
                    opt.textContent = g.name || g.title || (`Group ${opt.value}`);
                    sessionGroupSelect.appendChild(opt);
                });
                sessionGroupSelect.disabled = false;
                createSessionSubmit.disabled = false;
            } catch (e) {
                console.error('Could not load groups:', e);
                sessionGroupSelect.innerHTML = '<option value="">Failed to load groups</option>';
                sessionGroupSelect.disabled = true;
                createSessionSubmit.disabled = true;
            }
        }

        createSessionBtnLanding?.addEventListener('click', async () => {
            await populateGroupSelect();
            try { new bootstrap.Modal(createSessionModalEl).show(); } catch(e){ createSessionModalEl.style.display='block'; }
        });

        joinSessionBtnLanding?.addEventListener('click', () => {
            try { new bootstrap.Modal(joinSessionModalEl).show(); } catch(e){ joinSessionModalEl.style.display='block'; }
        });

        createSessionSubmit?.addEventListener('click', async () => {
            const gid = sessionGroupSelect?.value;
            const title = sessionNameInput?.value || '';
            if (!gid) return alert('Please select a group to create this session for.');
            createSessionSubmit.disabled = true;
            createSessionSubmit.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
            try {
                const res = await fetch(`/api/groups/${gid}/whiteboards`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify({ title })
                });
                const body = await res.json();
                if (!res.ok) throw new Error(body.message || 'Failed to create session');
                const invite = (body.data && body.data.invite_url) || body.invite_url || '/whiteboard';
                createdSessionLink.value = invite.startsWith('http') ? invite : (window.location.origin + invite);
                try { new bootstrap.Modal(sessionCreatedModalEl).show(); } catch(e){ sessionCreatedModalEl.style.display='block'; }
                try { loadMySessions(); } catch(e){}
            } catch (e) {
                console.error('Create session failed:', e);
                alert(e.message || 'Could not create session');
            } finally {
                createSessionSubmit.disabled = false;
                createSessionSubmit.innerHTML = 'Create Session';
            }
        });

        goToSessionBtn?.addEventListener('click', () => {
            const url = createdSessionLink?.value;
            if (url) window.location.href = url;
        });

        joinSessionSubmit?.addEventListener('click', () => {
            const val = document.getElementById('joinSessionId')?.value?.trim();
            if (!val) return alert('Please enter a session ID or link');
            let id = val;
            try {
                const u = new URL(val, window.location.origin);
                const s = new URLSearchParams(u.search).get('session');
                if (s) id = s;
            } catch (e) { }
            window.location.href = `/whiteboard?session=${encodeURIComponent(id)}`;
        });
        
        async function loadMySessions() {
            const listEl = document.getElementById('mySessionsListLanding');
            const cardEl = document.getElementById('mySessionsCardLanding');
            if (!listEl || !cardEl) return;
            listEl.innerHTML = '<div class="list-group-item">Loading...</div>';
            try {
                const res = await fetch('/api/whiteboards/mine', { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) throw new Error('Failed to fetch sessions');
                const body = await res.json();
                const sessions = (body.data && body.data.whiteboards) || [];
                if (!sessions.length) {
                    cardEl.style.display = 'none';
                    return;
                }
                cardEl.style.display = 'block';
                listEl.innerHTML = '';
                sessions.forEach(wb => {
                    const li = document.createElement('div');
                    li.className = 'list-group-item d-flex justify-content-between align-items-center';
                    li.id = `session-item-${wb.id}`;
                    const title = wb.title || 'Untitled Session';
                    const groupName = wb.group_name ? `<div class="small text-muted">${wb.group_name}</div>` : '';
                    li.innerHTML = `<div style="min-width:0;"><div class="fw-medium text-truncate" title="${title}">${title}</div>${groupName}</div><div class="d-flex gap-2"><a class="btn btn-sm btn-primary" href="/whiteboard?session=${wb.id}">Go</a><button class="btn btn-sm btn-danger end-session-btn">End</button></div>`;
                    const endBtn = li.querySelector('.end-session-btn');
                    endBtn.addEventListener('click', async () => {
                        if (!confirm('End session for everyone?')) return;
                        await endSession(wb.id);
                    });
                    listEl.appendChild(li);
                });
            } catch (e) {
                console.error('Could not load my sessions:', e);
                document.getElementById('mySessionsListLanding').innerHTML = '<div class="list-group-item text-muted">Could not load sessions</div>';
            }
        }

        async function endSession(id) {
            try {
                const res = await fetch(`/api/whiteboards/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
                const body = await res.json();
                if (!res.ok) throw new Error(body.message || 'Failed to end session');
                if (sessionId && sessionId === id) {
                    window.location.href = '/whiteboard';
                    return;
                }
                const el = document.getElementById(`session-item-${id}`);
                if (el) el.remove();
                const listEl = document.getElementById('mySessionsListLanding');
                if (listEl && listEl.children.length === 0) document.getElementById('mySessionsCardLanding').style.display = 'none';
                alert(body.message || 'Session ended');
            } catch (e) {
                console.error('Failed to end session:', e);
                alert(e.message || 'Could not end session');
            }
        }

        (function setupFullscreen() {
            const fsToggle = document.getElementById('fullscreenToggleBtn');
            const canvasContainerEl = document.getElementById('canvasContainer');
            const remoteFsBtn = document.getElementById('fullscreenBtn');
            const remoteContainer = document.getElementById('remoteVideoContainer');

            let _wbPrev = null;
            async function enterWhiteboardFullscreen() {
                if (!canvasContainerEl) return;
                _wbPrev = { width: canvas.width, height: canvas.height };

                // Save previous visible state of the controls so we can restore later
                const controlsEl = document.getElementById('sessionControls');
                const prevControlsDisplay = controlsEl ? controlsEl.style.display : null;
                canvasContainerEl.dataset._prevControlsDisplay = prevControlsDisplay || '';

                // Save inline canvas height to restore later
                canvasContainerEl.dataset._prevCanvasHeight = canvas.style.height || '';

                try {
                    if (canvasContainerEl.requestFullscreen) {
                        await canvasContainerEl.requestFullscreen();
                    } else if (canvasContainerEl.webkitRequestFullscreen) {
                        canvasContainerEl.webkitRequestFullscreen();
                    } else {
                        canvasContainerEl.classList.add('whiteboard-fullscreen');
                    }
                } catch (e) {
                    canvasContainerEl.classList.add('whiteboard-fullscreen');
                }

                // Hide floating session controls to prevent overlapping content
                try { if (controlsEl) controlsEl.style.display = 'none'; } catch(e){}

                // Force canvas to fill viewport as well (some browsers keep inline style)
                try { canvas.style.height = '100vh'; canvas.style.width = '100%'; } catch(e){}

                try {
                    // Trigger resize logic which will redraw history
                    const evt = new Event('resize');
                    window.dispatchEvent(evt);
                } catch (e) { }
                
                let exit = document.getElementById('wb-fs-exit');
                if (!exit) {
                    exit = document.createElement('button');
                    exit.id = 'wb-fs-exit';
                    exit.className = 'btn btn-light fullscreen-exit-btn';
                    exit.innerHTML = '<i class="fas fa-times"></i>';
                    exit.addEventListener('click', exitWhiteboardFullscreen);
                    // Append inside the whiteboard container so it is visible in native fullscreen
                    canvasContainerEl.appendChild(exit);
                }

                // Create fullscreen floating controls (clear, undo, brush toggle)
                let fsControls = document.getElementById('wb-fs-controls');
                if (!fsControls) {
                    fsControls = document.createElement('div');
                    fsControls.id = 'wb-fs-controls';
                    fsControls.className = 'fullscreen-controls';

                    const clearBtnFs = document.createElement('button');
                    clearBtnFs.id = 'wb-clear-btn';
                    clearBtnFs.className = 'btn btn-light';
                    clearBtnFs.title = 'Clear Whiteboard';
                    clearBtnFs.innerHTML = '<i class="fas fa-trash"></i>';

                    const undoBtnFs = document.createElement('button');
                    undoBtnFs.id = 'wb-undo-btn';
                    undoBtnFs.className = 'btn btn-light';
                    undoBtnFs.title = 'Undo';
                    undoBtnFs.innerHTML = '<i class="fas fa-undo"></i>';

                    const brushToggleFs = document.createElement('button');
                    brushToggleFs.id = 'wb-brush-toggle-btn';
                    brushToggleFs.className = 'btn btn-light';
                    brushToggleFs.title = 'Toggle Brush / Eraser';
                    brushToggleFs.innerHTML = '<i class="fas fa-paint-brush"></i>';

                    fsControls.appendChild(clearBtnFs);
                    fsControls.appendChild(undoBtnFs);
                    fsControls.appendChild(brushToggleFs);

                    // Append inside the whiteboard container so controls are visible in native fullscreen
                    canvasContainerEl.appendChild(fsControls);

                    // Attach handlers
                    clearBtnFs.addEventListener('click', () => document.getElementById('clearBtn')?.click());
                    undoBtnFs.addEventListener('click', () => undoLastStroke());
                    brushToggleFs.addEventListener('click', () => {
                        isErasing = !isErasing;
                        brushToggleFs.innerHTML = isErasing ? '<i class="fas fa-eraser"></i>' : '<i class="fas fa-paint-brush"></i>';
                        // small visual indication
                        brushToggleFs.classList.toggle('btn-danger', isErasing);
                    });
                }
            }

            function exitWhiteboardFullscreen() {
                if (!canvasContainerEl) return;
                try {
                   if(document.fullscreenElement) document.exitFullscreen();
                } catch(e) {}
                canvasContainerEl.classList.remove('whiteboard-fullscreen');

                // Restore session controls visibility
                try {
                    const controlsEl = document.getElementById('sessionControls');
                    const prev = canvasContainerEl.dataset._prevControlsDisplay || '';
                    if (controlsEl) controlsEl.style.display = prev || '';
                } catch(e) {}

                // Restore canvas inline height if we changed it
                try {
                    const prevH = canvasContainerEl.dataset._prevCanvasHeight || '';
                    canvas.style.height = prevH || '50vh';
                    canvas.style.width = '100%';
                } catch(e) {}
                
                try {
                    // Trigger resize to restore original scale and redraw
                    const evt = new Event('resize');
                    window.dispatchEvent(evt);
                } catch (e) { }
                
                const exit = document.getElementById('wb-fs-exit');
                if (exit) exit.remove();
                // Remove fullscreen floating controls if present
                const fsControls = document.getElementById('wb-fs-controls');
                if (fsControls) fsControls.remove();
            }

            if (fsToggle) {
                fsToggle.addEventListener('click', () => {
                    if (canvasContainerEl.classList.contains('whiteboard-fullscreen') || document.fullscreenElement === canvasContainerEl) exitWhiteboardFullscreen();
                    else enterWhiteboardFullscreen();
                });
            }

            if (remoteFsBtn && remoteContainer) {
                remoteFsBtn.addEventListener('click', async () => {
                    try {
                        if (document.fullscreenElement) await document.exitFullscreen();
                        else await remoteContainer.requestFullscreen();
                    } catch (e) {
                        remoteContainer.classList.toggle('whiteboard-fullscreen');
                    }
                });
            }
        })();
        
    })();
</script>
{% endblock %}