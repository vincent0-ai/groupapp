{% extends "base.html" %}

{% block title %}Whiteboard - Discussio{% endblock %}

{% block head %}
<style>
    canvas {
        border: 2px solid var(--border-color);
        background: #fff;
        cursor: crosshair;
        border-radius: 8px;
        touch-action: none;
    }

    .controls {
        margin-bottom: 15px;
    }

    /* Fullscreen mode styles */
    .whiteboard-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        background: #fff !important;
        border-radius: 0 !important;
        border: none !important;
    }

    .fullscreen-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        display: flex;
        gap: 10px;
        background: rgba(255,255,255,0.95);
        padding: 10px 15px;
        border-radius: 30px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .fullscreen-controls button {
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .fullscreen-exit-btn {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10000;
        border-radius: 50%;
        width: 45px;
        height: 45px;
    }

    @media (max-width: 768px) {
        .fullscreen-toggle-btn {
            display: inline-flex !important;
        }
    }

    @media (min-width: 769px) {
        .fullscreen-toggle-btn {
            display: none !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header mb-4" style="background: var(--gradient-primary); border-radius: 20px; padding: 2rem; color: white;">
    <div class="d-flex align-items-center gap-3">
        <div>
            <h1 class="mb-1" style="font-size: 1.75rem; font-weight: 700;">Collaborate</h1>
            <p class="mb-0 opacity-75">Draw and collaborate in real-time with your group</p>
        </div>
    </div>
</div>

<!-- Landing View -->
<div id="landingView" style="display:none;">
    <div class="row mt-4">
        <div class="col-md-8 offset-md-2">
            <div class="card shadow-sm border-0 mb-4" style="overflow: hidden;">
                <div class="card-body text-center p-5" style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);">
                    <div style="width: 80px; height: 80px; background: var(--gradient-primary); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto 1.5rem;">
                        <i class="fas fa-palette fa-2x text-white"></i>
                    </div>
                    <h3 class="mb-2 fw-bold">Start Collaborating</h3>
                    <p class="text-muted mb-4">Create a new whiteboard session or join an existing one</p>
                    <div class="d-flex justify-content-center gap-3 flex-wrap">
                        <button id="createSessionBtnLanding" class="btn btn-primary btn-lg px-4">
                            <i class="fas fa-plus-circle me-2"></i> Create Session
                        </button>
                        <button id="joinSessionBtnLanding" class="btn btn-outline-primary btn-lg px-4">
                            <i class="fas fa-sign-in-alt me-2"></i> Join Session
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="card shadow-sm border-0" id="mySessionsCardLanding" style="display:none;">
                <div class="card-header" style="background: transparent; border-bottom: 1px solid var(--border-color);">
                    <h5 class="mb-0"><i class="fas fa-list text-primary me-2"></i> My Active Sessions</h5>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush" id="mySessionsListLanding">
                        <!-- Sessions will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Session View -->
<div id="sessionView" class="row mt-4" style="display:none;">
    <div class="col-lg-2">
        <div class="card shadow-sm border-0 mb-3" style="overflow: hidden;">
            <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="card-title mb-0 fw-semibold"><i class="fas fa-paint-brush text-primary me-2"></i>Tools</h6>
                        <button class="btn btn-sm btn-outline-primary" data-bs-toggle="collapse" data-bs-target="#drawingToolsCollapse" aria-expanded="false" aria-controls="drawingToolsCollapse" id="toggleDrawingTools" style="font-size: 0.75rem;">Show</button>
                    </div>
                    <div id="permissionStatus" class="mb-2 text-muted small mt-2"></div>
                    <div class="collapse" id="drawingToolsCollapse">
                        <div class="controls mb-3 mt-3">
                            <label for="colorPicker" class="form-label small fw-medium">Color</label>
                            <input type="color" class="form-control form-control-color w-100" id="colorPicker" value="#000000" style="height: 40px; border-radius: 10px;">
                        </div>
                        <div class="controls mb-3">
                            <label for="brushSize" class="form-label small fw-medium">Brush Size: <span id="sizeValue" class="badge bg-primary">3</span>px</label>
                            <input type="range" class="form-range" id="brushSize" min="1" max="20" value="3">
                        </div>
                        <div class="controls mb-3">
                            <label for="opacity" class="form-label small fw-medium">Opacity</label>
                            <input type="range" class="form-range" id="opacity" min="0" max="1" step="0.1" value="1">
                        </div>
                        <div class="btn-group-vertical w-100 gap-2">
                            <button id="clearBtn" class="btn btn-warning">
                                <i class="fas fa-trash me-1"></i> Clear
                            </button>
                            <button id="undoBtn" class="btn btn-outline-secondary">
                                <i class="fas fa-undo me-1"></i> Undo
                            </button>
                            <button id="downloadBtn" class="btn btn-info text-white">
                                <i class="fas fa-download me-1"></i> Save
                            </button>
                        </div>
                    </div>
                    <div class="d-grid mt-3" id="leaveSessionContainer">
                        <a href="/whiteboard" class="btn btn-sm btn-outline-danger"><i class="fas fa-sign-out-alt me-1"></i>Leave</a>
                    </div>
            </div>
        </div>

        <div class="card mt-3 shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header" style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); border-bottom: none;">
                <h6 class="mb-0 fw-semibold"><i class="fas fa-users text-primary me-2"></i> Participants</h6>
            </div>
            <div class="card-body">
                <div id="participantsList">
                    <small class="text-body-secondary">Connecting...</small>
                </div>
                <div id="sessionControls" class="mt-3 border-top pt-2 d-flex flex-wrap gap-2"></div>
                <div id="inviteLinkContainer" class="mt-3 border-top pt-2"></div>
                <div id="audioFilesContainer" class="mt-3 border-top pt-2"></div>
            </div>
        </div>
    </div>

    <div class="col-lg-10">
        <div class="card shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header d-flex justify-content-between align-items-center d-lg-none" style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); border-bottom: none;">
                <span class="fw-semibold"><i class="fas fa-chalkboard text-primary me-2"></i>Whiteboard</span>
                <button id="fullscreenToggleBtn" class="btn btn-sm btn-primary fullscreen-toggle-btn">
                    <i class="fas fa-expand me-1"></i> Fullscreen
                </button>
            </div>
            <div class="card-body overflow-auto text-center" id="canvasContainer" style="background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%); padding: 1rem;">
                <div style="position:relative; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <canvas id="whiteboard" style="width:100%;height:50vh;display:block; background: white;" width="1200" height="600"></canvas>
                    <div id="canvasOverlay" style="position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,0.85); backdrop-filter: blur(4px);">
                        <div class="text-muted"><i class="fas fa-lock me-2"></i>You don't have permission to draw in this session</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block modals %}
<!-- Create/Join Session Modals -->
<!-- Create Session Modal -->
<div class="modal fade" id="createSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-plus-circle me-2"></i>Create Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="text-muted mb-3">Select which group this session is for:</p>
                <div class="mb-3">
                    <label for="sessionGroupSelect" class="form-label fw-medium">Group</label>
                    <select id="sessionGroupSelect" class="form-select" style="border-radius: 10px;"></select>
                </div>
                <div class="mb-3">
                    <label for="sessionNameInput" class="form-label fw-medium">Session Name</label>
                    <input type="text" class="form-control" id="sessionNameInput" placeholder="Enter session name (optional)" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="createSessionSubmit" type="button" class="btn btn-primary">Create Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Session Created Modal -->
<div class="modal fade" id="sessionCreatedModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-success); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-check-circle me-2"></i>Session Created</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="mb-3">Share this link with your group members:</p>
                <div class="input-group">
                    <input type="text" class="form-control" id="createdSessionLink" readonly style="border-radius: 10px 0 0 10px;">
                    <button class="btn btn-primary" type="button" onclick="navigator.clipboard.writeText(document.getElementById('createdSessionLink').value); this.innerHTML='<i class=\'fas fa-check\'></i>'; setTimeout(()=>this.innerHTML='<i class=\'fas fa-copy\'></i>', 2000);" style="border-radius: 0 10px 10px 0;"><i class="fas fa-copy"></i></button>
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
                <button id="goToSessionBtn" type="button" class="btn btn-primary"><i class="fas fa-arrow-right me-1"></i>Go to Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Join Session Modal -->
<div class="modal fade" id="joinSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-sign-in-alt me-2"></i>Join Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <div class="mb-3">
                    <label class="form-label fw-medium">Session ID</label>
                    <input id="joinSessionId" class="form-control" placeholder="Enter session ID or paste invite link" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="joinSessionSubmit" type="button" class="btn btn-primary"><i class="fas fa-sign-in-alt me-1"></i>Join</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    (() => {
        const token = localStorage.getItem('token');
        const userId = localStorage.getItem('userId');

        if (!token || !userId) {
            // Save current URL to redirect back after login
            sessionStorage.setItem('redirectAfterLogin', window.location.href);
            window.location.href = "{{ url_for('auth_page') }}";
            return;
        }

        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const sessionId = new URLSearchParams(window.location.search).get('session');
        const participantsEl = document.getElementById('participantsList');

        // View Toggling Logic
        const landingView = document.getElementById('landingView');
        const sessionView = document.getElementById('sessionView');

        if (sessionId) {
            if (landingView) landingView.style.display = 'none';
            if (sessionView) sessionView.style.display = 'flex';
        } else {
            if (landingView) landingView.style.display = 'block';
            if (sessionView) sessionView.style.display = 'none';
        }

        console.log('whiteboard script loaded');
        console.log('sessionId:', sessionId, 'userId:', userId);

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let history = [];
        let participants = {};
        let isCreator = false;

        const socket = io();

        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const opacity = document.getElementById('opacity');

        if (brushSize) {
            brushSize.addEventListener('input', (e) => {
                document.getElementById('sizeValue').textContent = e.target.value;
            });
        }

        function getPos(clientX, clientY) {
            if (!canvas) return { x: 0, y: 0 };
            const rect = canvas.getBoundingClientRect();
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(x0, y0, x1, y1, color, size, alpha) {
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.strokeStyle = color ?? colorPicker.value;
            ctx.lineWidth = size ?? Number(brushSize.value);
            ctx.globalAlpha = alpha ?? Number(opacity.value);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function saveHistory() {
            try {
                history.push(canvas.toDataURL());
            } catch {
                // ignore
            }
        }

        function emitDraw(x0, y0, x1, y1) {
            socket.emit('whiteboard_draw', {
                room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                user_id: userId,
                drawing_data: {
                    x0,
                    y0,
                    x1,
                    y1,
                    color: colorPicker.value,
                    size: Number(brushSize.value),
                    opacity: Number(opacity.value)
                }
            });
        }

        // Store canvas image data to preserve across resize/visibility changes
        let savedCanvasData = null;
        
        function saveCanvasState() {
            if (!canvas || !ctx) return;
            try {
                savedCanvasData = canvas.toDataURL();
            } catch (e) {
                console.error('Could not save canvas state:', e);
            }
        }
        
        function restoreCanvasState() {
            if (!canvas || !ctx || !savedCanvasData) return;
            const img = new Image();
            img.onload = () => {
                // Clear and redraw
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            };
            img.src = savedCanvasData;
        }

        // Resize canvas to container size and handle high DPI screens
        function resizeCanvas(preserveContent = true) {
            if (!canvas || !ctx) return;
            
            // Save current canvas content before resize
            if (preserveContent) {
                saveCanvasState();
            }
            
            const rect = canvas.getBoundingClientRect();
            const ratio = window.devicePixelRatio || 1;
            canvas.width = Math.max(300, Math.floor(rect.width * ratio));
            canvas.height = Math.max(200, Math.floor(rect.height * ratio));
            // Reset scaling for drawing operations
            ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            
            // Restore canvas content after resize
            if (preserveContent) {
                restoreCanvasState();
            }
        }
        
        // Handle visibility change (user switches tabs/apps on mobile)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is being hidden - save canvas state
                saveCanvasState();
            } else {
                // Page is visible again - restore canvas state
                // Small delay to ensure canvas is ready
                setTimeout(() => {
                    restoreCanvasState();
                }, 100);
            }
        });
        
        // Handle page focus/blur for additional mobile browser support
        window.addEventListener('blur', () => {
            saveCanvasState();
        });
        
        window.addEventListener('focus', () => {
            setTimeout(() => {
                restoreCanvasState();
            }, 100);
        });
        
        window.addEventListener('resize', () => {
            if (canvas) {
                try { history.push(canvas.toDataURL()); } catch{}
                resizeCanvas(true);
            }
        });
        if (canvas) resizeCanvas(false);

        // Mouse events
        if (canvas) {
            canvas.addEventListener('mousedown', (e) => {
                if (!canDraw) return;
                isDrawing = true;
                const p = getPos(e.clientX, e.clientY);
                lastX = p.x;
                lastY = p.y;
                saveHistory();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const p = getPos(e.clientX, e.clientY);
                draw(lastX, lastY, p.x, p.y);
                emitDraw(lastX, lastY, p.x, p.y);
                lastX = p.x;
                lastY = p.y;
            });
        }

        function stopDrawing() {
            isDrawing = false;
        }

        if (canvas) {
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!canDraw) return;
                const t = e.touches[0];
                isDrawing = true;
                const p = getPos(t.clientX, t.clientY);
                lastX = p.x;
                lastY = p.y;
                saveHistory();
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                const t = e.touches[0];
                const p = getPos(t.clientX, t.clientY);
                draw(lastX, lastY, p.x, p.y);
                emitDraw(lastX, lastY, p.x, p.y);
                lastX = p.x;
                lastY = p.y;
            }, { passive: false });

            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);
        }

        // Controls
        const clearBtn = document.getElementById('clearBtn');
        if (clearBtn) {
            clearBtn.addEventListener('click', async () => {
                if (await showCustomConfirm('Clear the entire whiteboard?', 'Confirm Clear')) {
                    // Local clear
                    if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);
                    history = [];
                    savedCanvasData = null; // Clear saved state too
                    // Emit clear event
                    socket.emit('clear_board', { 
                        room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', 
                        user_id: userId 
                    });
                }
            });
        }

        socket.on('board_cleared', () => {
            if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);
            history = [];
            savedCanvasData = null; // Clear saved state when board is cleared
        });

        const undoBtn = document.getElementById('undoBtn');
        if (undoBtn) {
            undoBtn.addEventListener('click', () => {
                if (history.length === 0) return;
                history.pop();
                if (history.length === 0) {
                    if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }

                const img = new Image();
                img.src = history[history.length - 1];
                img.onload = () => {
                    if (ctx && canvas) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                    }
                };
            });
        }

        const downloadBtn = document.getElementById('downloadBtn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', () => {
                if (!canvas) return;
                const link = document.createElement('a');
                link.href = canvas.toDataURL();
                link.download = 'whiteboard-' + new Date().getTime() + '.png';
                link.click();
            });
        }

        // Socket events
        let canDraw = true;
        let canSpeak = true;
        
        // WebRTC state (declared early for access in socket handlers)
        let isInCall = false;
        let localStream = null;
        const peers = {}; // Map of userId -> RTCPeerConnection
        let liveBtn = null; // Will be created later

        async function loadSessionInfo() {
            if (!sessionId) return;
            try {
                const res = await fetch(`/api/whiteboards/${sessionId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                
                // Check if session has ended
                if (res.status === 410) {
                    await showCustomAlert('This session has ended', 'Session Ended');
                    window.location.href = '/whiteboard';
                    return;
                }
                
                if (res.status === 404) {
                    await showCustomAlert('Session not found', 'Error');
                    window.location.href = '/whiteboard';
                    return;
                }
                
                if (!res.ok) {
                    const errData = await res.json();
                    await showCustomAlert(errData.message || 'Failed to load session', 'Error');
                    window.location.href = '/whiteboard';
                    return;
                }
                
                const data = await res.json();
                const wb = data.data;
                    
                    // Update page title
                    if (wb.title) {
                        document.querySelector('h1').innerHTML = `<i class="fas fa-chalkboard"></i> ${wb.title}`;
                        document.title = `${wb.title} - Discussio`;
                    }
                    
                    // Set creator status early
                    if (wb.created_by && wb.created_by === userId) {
                        isCreator = true;
                        // Change Leave button to End Session for creator
                        const leaveBtnContainer = document.getElementById('leaveSessionContainer');
                        if (leaveBtnContainer) {
                            leaveBtnContainer.innerHTML = `
                                <button id="endSessionBtn" class="btn btn-sm btn-danger w-100">End Session</button>
                            `;
                            const endSessionBtn = document.getElementById('endSessionBtn');
                            if (endSessionBtn) {
                                endSessionBtn.addEventListener('click', async () => {
                                    if (confirm('Are you sure you want to end this session? It will be closed for everyone.')) {
                                        await endSession(sessionId);
                                    }
                                });
                            }
                        }
                    }

                    if (wb.can_draw) {
                        const ids = wb.can_draw.map(x => x.toString());
                        canDraw = ids.includes(userId);
                    }
                    if (wb.can_speak) {
                        const ids2 = wb.can_speak.map(x => x.toString());
                        canSpeak = ids2.includes(userId);
                    }
                    // Setup participants initial state
                    if (wb.participants) {
                        wb.participants.forEach(p => {
                            const uid = p.id || p._id || p;
                            participants[uid] = { name: p.username || p.full_name || 'User ' + String(uid).substr(-4), avatar_url: p.avatar_url || '', can_draw: wb.can_draw ? wb.can_draw.map(x => x.toString()).includes(uid) : false, can_speak: wb.can_speak ? wb.can_speak.map(x => x.toString()).includes(uid) : false };
                        });
                        renderParticipants();
                    }
                    // Show share link if creator
                    if (isCreator) {
                        const inviteContainer = document.getElementById('inviteLinkContainer');
                        if (inviteContainer) {
                            const shareUrl = window.location.origin + '/whiteboard?session=' + wb._id;
                            inviteContainer.innerHTML = `
                                <div class="d-flex align-items-center gap-2">
                                    <small class="text-muted"><i class="fas fa-share-alt me-1"></i>Share:</small>
                                    <button class="btn btn-xs btn-outline-primary" onclick="navigator.clipboard.writeText('${shareUrl}'); this.innerHTML='<i class=\\'fas fa-check\\'></i> Copied'; setTimeout(() => this.innerHTML='<i class=\\'fas fa-copy\\'></i> Copy Link', 2000);" style="padding: 2px 8px; font-size: 0.75rem;">
                                        <i class="fas fa-copy"></i> Copy Link
                                    </button>
                                </div>
                            `;
                        }
                    }
                    // Render audio files list
                    if (wb.audio_files && wb.audio_files.length) {
                        const audioContainer = document.getElementById('audioFilesContainer');
                        if (audioContainer) {
                            audioContainer.innerHTML = ''; // Clear previous
                            const list = document.createElement('div');
                            list.className = 'mt-2';
                            wb.audio_files.forEach(f => {
                                const row = document.createElement('div');
                                const playBtn = document.createElement('button');
                                playBtn.className = 'btn btn-sm btn-outline-secondary me-2';
                                playBtn.textContent = 'Play';
                                playBtn.addEventListener('click', async () => {
                                    const res = await fetch(`/api/files/${f.id}`, { headers: { 'Authorization': `Bearer ${token}` } });
                                    if (res.ok) {
                                        const data = await res.json();
                                        const url = data.data.download_url;
                                        const audioEl = document.createElement('audio');
                                        audioEl.src = url; audioEl.controls = true; list.appendChild(audioEl);
                                    }
                                });
                                row.appendChild(playBtn);
                                row.appendChild(document.createTextNode(f.filename || f.filename || 'Audio'));
                                list.appendChild(row);
                            });
                            audioContainer.appendChild(list);
                        }
                    }
                    // Render existing drawings
                    if (wb.drawing_data && Array.isArray(wb.drawing_data)) {
                        wb.drawing_data.forEach(d => {
                            draw(d.x0, d.y0, d.x1, d.y1, d.color, d.size, d.opacity);
                        });
                    }
            } catch (e) {
                console.error('Failed to fetch session info', e);
            }
        }

        socket.on('connect_response', () => {
            if (participantsEl) {
                participantsEl.innerHTML = '<small class="text-body-secondary">Connected</small>';
            }
        });
        
        // Handle session ended by creator
        socket.on('session_ended', async (data) => {
            console.log('Session ended:', data);
            // Stop any active calls
            if (isInCall && typeof stopCall === 'function') {
                stopCall();
            }
            await showCustomAlert('This session has been ended by the host', 'Session Ended');
            window.location.href = '/whiteboard';
        });
        
        // Load session info (permissions)
        loadSessionInfo();
        // Update permission status UI element and overlay
        function updatePermissionUI() {
            const el = document.getElementById('permissionStatus');
            if (el) el.textContent = canDraw ? 'You can draw' : 'You cannot draw';
            const overlay = document.getElementById('canvasOverlay');
            if (overlay) overlay.style.display = canDraw ? 'none' : 'flex';
        }
        setInterval(updatePermissionUI, 500);

        // Remote draw updates from other users
        socket.on('draw_update', (data) => {
            const d = data?.drawing_data;
            if (!d) return;
            draw(d.x0, d.y0, d.x1, d.y1, d.color, d.size, d.opacity);
        });

        // Update participants list
        function renderParticipants() {
            participantsEl.innerHTML = '';
            for (const [uid, meta] of Object.entries(participants)) {
                const el = document.createElement('div');
                el.className = 'd-flex align-items-center justify-content-between mb-2';
                const left = document.createElement('div');
                left.className = 'd-flex align-items-center';
                const avatarSrc = meta.avatar_url || `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(meta.name || meta.username || uid)}`;
                const avatarHtml = `<img src="${avatarSrc}" class="rounded-circle me-2" width="24" height="24"/>`;
                left.innerHTML = avatarHtml + `<span class="small fw-medium" style="color: var(--text-dark);">${meta.name || uid}</span>`;
                el.appendChild(left);
                const right = document.createElement('div');
                right.className = 'd-flex gap-1';
                if (isCreator && uid !== userId) {
                    const grantDraw = document.createElement('button');
                    grantDraw.className = 'btn btn-xs ' + (meta.can_draw ? 'btn-primary' : 'btn-outline-primary');
                    grantDraw.innerHTML = meta.can_draw ? '<i class="fas fa-pencil-alt"></i>' : '<i class="fas fa-pencil-alt"></i>';
                    grantDraw.title = meta.can_draw ? 'Revoke Draw' : 'Grant Draw';
                    grantDraw.style.cssText = 'padding: 2px 6px; font-size: 0.7rem;';
                    grantDraw.addEventListener('click', () => {
                        socket.emit(meta.can_draw ? 'revoke_draw' : 'grant_draw', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: uid, requester_id: userId });
                    });
                    const grantSpeak = document.createElement('button');
                    grantSpeak.className = 'btn btn-xs ' + (meta.can_speak ? 'btn-success' : 'btn-outline-secondary');
                    grantSpeak.innerHTML = meta.can_speak ? '<i class="fas fa-microphone"></i>' : '<i class="fas fa-microphone-slash"></i>';
                    grantSpeak.title = meta.can_speak ? 'Revoke Speak' : 'Grant Speak';
                    grantSpeak.style.cssText = 'padding: 2px 6px; font-size: 0.7rem;';
                    grantSpeak.addEventListener('click', () => {
                        socket.emit(meta.can_speak ? 'revoke_speak' : 'grant_speak', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: uid, requester_id: userId });
                    });
                    right.appendChild(grantDraw);
                    right.appendChild(grantSpeak);
                    if (meta.raised) {
                        const clearHand = document.createElement('button');
                        clearHand.className = 'btn btn-xs btn-outline-danger';
                        clearHand.innerHTML = '<i class="fas fa-hand-paper"></i>';
                        clearHand.title = 'Clear Hand';
                        clearHand.style.cssText = 'padding: 2px 6px; font-size: 0.7rem;';
                        clearHand.addEventListener('click', () => {
                            socket.emit('clear_hand', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: uid });
                        });
                        right.appendChild(clearHand);
                    }
                } else {
                    const statusText = document.createElement('small');
                    statusText.className = 'text-muted';
                    statusText.textContent = (meta.can_draw ? '✏️' : '') + (meta.raised ? ' ✋' : '');
                    right.appendChild(statusText);
                }
                el.appendChild(right);
                participantsEl.appendChild(el);
            }
        }

        socket.on('user_joined', (data) => {
            const uid = data.user_id;
            const p = data.profile;
            const name = p?.username || p?.full_name || 'User ' + uid.substr(-4);
            const avatar = p?.avatar_url || '';
            if (!participants[uid]) participants[uid] = { name, avatar_url: avatar, can_draw: false, can_speak: false };
            renderParticipants();
        });
        socket.on('user_left', (data) => {
            const uid = data.user_id;
            delete participants[uid];
            renderParticipants();
        });

        socket.on('permissions_updated', (data) => {
            const can_draw = data.can_draw || [];
            const can_speak = data.can_speak || [];
            for (const uid of Object.keys(participants)) {
                participants[uid].can_draw = can_draw.includes(uid);
                participants[uid].can_speak = can_speak.includes(uid);
            }
            // Update local flags too
            const hadSpeakPermission = canSpeak;
            canDraw = can_draw.includes(userId);
            canSpeak = can_speak.includes(userId);
            
            // If user just got speak permission and is in a call, enable their microphone
            if (!hadSpeakPermission && canSpeak && isInCall && typeof enableMicrophone === 'function') {
                enableMicrophone();
            }
            
            // If user lost speak permission while in call, disable their microphone
            if (hadSpeakPermission && !canSpeak && isInCall && localStream) {
                disableMicrophone();
            }
            
            // Update button text if in call (liveBtn may not exist yet)
            if (isInCall && typeof liveBtn !== 'undefined' && liveBtn) {
                if (canSpeak && localStream) {
                    liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave Call';
                } else if (!canSpeak || !localStream) {
                    liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave (Listen Only)';
                }
            }
            
            renderParticipants();
        });

        socket.on('hand_raised', (data) => {
            const uid = data.user_id;
            const profile = data.profile;
            if (!participants[uid]) participants[uid] = { name: profile?.full_name || profile?.username || 'User ' + uid.substr(-4), avatar_url: profile?.avatar_url || '', can_draw: false, can_speak: false };
            participants[uid].raised = true;
            renderParticipants();
        });

        socket.on('hand_cleared', (data) => {
            const uid = data.user_id;
            if (participants[uid]) {
                participants[uid].raised = false;
                renderParticipants();
            }
        });

        // Audio: start/stop recording and emit base64 data; also upload recorded clip on stop
        let mediaRecorder = null;
        let isSpeaking = false;
        let audioChunks = [];
        
        const controlsContainer = document.getElementById('sessionControls');
        
        const speakBtn = document.createElement('button');
        speakBtn.className = 'btn btn-sm btn-outline-primary';
        speakBtn.innerHTML = '<i class="fas fa-microphone"></i> Push to Talk';
        if (controlsContainer) controlsContainer.appendChild(speakBtn);
        
        // Live audio call button
        liveBtn = document.createElement('button');
        liveBtn.className = 'btn btn-sm btn-outline-success';
        liveBtn.innerHTML = '<i class="fas fa-phone"></i> Join Call';
        if (controlsContainer) controlsContainer.appendChild(liveBtn);
        
        const raiseBtn = document.createElement('button');
        raiseBtn.className = 'btn btn-sm btn-outline-secondary';
        raiseBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Raise Hand';
        if (controlsContainer) controlsContainer.appendChild(raiseBtn);

        raiseBtn.addEventListener('click', async () => {
            socket.emit('raise_hand', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId });
            participants[userId] = participants[userId] || { name: 'You', avatar_url: '', can_draw: false, can_speak: false };
            participants[userId].raised = true;
            renderParticipants();
        });

        speakBtn.addEventListener('mousedown', async () => {
            if (!canSpeak) {
                alert('You are not permitted to speak in this session.');
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = e => {
                    audioChunks.push(e.data);
                    // Send chunks for near-realtime
                    const reader = new FileReader();
                    reader.onload = () => {
                        const b64 = reader.result.split(',')[1];
                        socket.emit('whiteboard_audio', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId, audio_b64: b64 });
                    };
                    reader.readAsDataURL(e.data);
                };
                mediaRecorder.start(200); // Smaller chunks for lower latency
                isSpeaking = true;
                speakBtn.className = 'btn btn-sm btn-danger';
                speakBtn.innerHTML = '<i class="fas fa-microphone"></i> Speaking...';
            } catch (err) {
                console.error('Error accessing microphone', err);
                alert('Could not access microphone');
            }
        });

        const stopSpeaking = () => {
            if (isSpeaking && mediaRecorder) {
                mediaRecorder.stop();
                mediaRecorder.stream && mediaRecorder.stream.getTracks().forEach(t => t.stop());
                // upload the recorded clip
                if (audioChunks.length > 0) {
                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    const form = new FormData();
                    form.append('file', blob, `whiteboard-${Date.now()}.webm`);
                    fetch(`/api/whiteboards/${sessionId}/upload_audio`, { method: 'POST', headers: { 'Authorization': `Bearer ${token}` }, body: form })
                        .then(r => r.json()).then(d => console.log('Uploaded audio clip', d)).catch(e => console.error('Upload failed', e));
                }
                audioChunks = [];
            }
            isSpeaking = false;
            speakBtn.className = 'btn btn-sm btn-outline-primary';
            speakBtn.innerHTML = '<i class="fas fa-microphone"></i> Push to Talk';
        };

        speakBtn.addEventListener('mouseup', stopSpeaking);
        speakBtn.addEventListener('mouseleave', stopSpeaking);
        speakBtn.addEventListener('touchend', stopSpeaking);

        // WebRTC live audio (low-latency)
        let pc = null;

        // Function to start WebRTC call
        async function startCall() {
            try {
                // Only get microphone if user has speak permission
                if (canSpeak) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Mute local audio playback to prevent echo
                    const localAudio = document.createElement('audio');
                    localAudio.srcObject = localStream;
                    localAudio.muted = true;
                    
                    liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave Call';
                } else {
                    // Join as listen-only
                    localStream = null;
                    liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave (Listen Only)';
                }
                
                isInCall = true;
                
                // Notify others that we are joining the call
                socket.emit('webrtc_join', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId });
                
                liveBtn.classList.remove('btn-outline-success');
                liveBtn.classList.add('btn-success');
            } catch (err) {
                console.error('Error accessing microphone', err);
                // Still allow joining as listen-only if mic access fails
                localStream = null;
                isInCall = true;
                socket.emit('webrtc_join', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId });
                liveBtn.classList.remove('btn-outline-success');
                liveBtn.classList.add('btn-success');
                liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave (Listen Only)';
            }
        }

        // Function to enable microphone after permission is granted
        async function enableMicrophone() {
            if (!isInCall || localStream) return; // Already have mic or not in call
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Add tracks to all existing peer connections
                Object.entries(peers).forEach(([peerId, peer]) => {
                    localStream.getTracks().forEach(track => {
                        peer.addTrack(track, localStream);
                    });
                });
                
                // Renegotiate with all peers
                for (const [peerId, peer] of Object.entries(peers)) {
                    try {
                        const offer = await peer.createOffer();
                        await peer.setLocalDescription(offer);
                        socket.emit('webrtc_offer', {
                            room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                            target: peerId,
                            sender: userId,
                            offer: offer
                        });
                    } catch (e) {
                        console.error('Error renegotiating with peer:', peerId, e);
                    }
                }
                
                liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave Call';
                console.log('Microphone enabled after permission grant');
            } catch (err) {
                console.error('Error enabling microphone:', err);
            }
        }

        // Function to disable microphone when permission is revoked
        function disableMicrophone() {
            if (!localStream) return;
            
            // Stop all tracks
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
            
            // Note: We don't remove tracks from peer connections, they will just stop sending
            // The connection stays open so user can still listen
            
            if (liveBtn) {
                liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i> Leave (Listen Only)';
            }
            console.log('Microphone disabled due to permission revocation');
        }

        // Function to stop WebRTC call
        function stopCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            isInCall = false;
            
            // Close all peer connections
            Object.values(peers).forEach(peer => peer.close());
            for (const key in peers) delete peers[key];
            
            // Notify others
            socket.emit('webrtc_leave', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId });
            
            liveBtn.classList.remove('btn-success');
            liveBtn.classList.add('btn-outline-success');
            liveBtn.innerHTML = '<i class="fas fa-phone"></i> Join Call';
        }

        liveBtn.addEventListener('click', () => {
            if (isInCall) {
                stopCall();
            } else {
                startCall();
            }
        });

        // Handle new user joining the call
        socket.on('webrtc_user_joined', async (data) => {
            const remoteUserId = data.user_id;
            if (remoteUserId === userId) return;
            if (!isInCall) return; // Only respond if we're in the call
            
            console.log('User joined call:', remoteUserId);
            
            // Close existing peer connection if any
            if (peers[remoteUserId]) {
                peers[remoteUserId].close();
            }
            
            // Create peer connection - always create it even if we have no stream
            const peer = createPeerConnection(remoteUserId);
            peers[remoteUserId] = peer;
            
            // Add local tracks if we have them (speaker)
            if (localStream) {
                localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
            }
            
            // Always create and send offer - even listen-only users need to establish connection
            // to receive audio from the other peer
            try {
                const offer = await peer.createOffer({
                    offerToReceiveAudio: true,  // We want to receive audio
                    offerToReceiveVideo: false
                });
                await peer.setLocalDescription(offer);
                socket.emit('webrtc_offer', {
                    room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                    target: remoteUserId,
                    sender: userId,
                    offer: offer
                });
            } catch (e) {
                console.error('Error creating offer:', e);
            }
        });

        // Handle list of existing users when we join a call
        // This ensures we connect to ALL users already in the call
        socket.on('webrtc_existing_users', async (data) => {
            const existingUsers = data.users || [];
            if (!isInCall) return;
            
            console.log('Existing users in call:', existingUsers);
            
            // Create peer connections to all existing users
            for (const remoteUserId of existingUsers) {
                if (remoteUserId === userId) continue;
                
                // Close existing peer connection if any
                if (peers[remoteUserId]) {
                    peers[remoteUserId].close();
                }
                
                // Create peer connection
                const peer = createPeerConnection(remoteUserId);
                peers[remoteUserId] = peer;
                
                // Add local tracks if we have them
                if (localStream) {
                    localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
                }
                
                // Send offer to this existing user
                try {
                    const offer = await peer.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: false
                    });
                    await peer.setLocalDescription(offer);
                    socket.emit('webrtc_offer', {
                        room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                        target: remoteUserId,
                        sender: userId,
                        offer: offer
                    });
                    console.log('Sent offer to existing user:', remoteUserId);
                } catch (e) {
                    console.error('Error creating offer for existing user:', remoteUserId, e);
                }
            }
        });

        // Handle user leaving the call
        socket.on('webrtc_user_left', (data) => {
            const remoteUserId = data.user_id;
            if (peers[remoteUserId]) {
                peers[remoteUserId].close();
                delete peers[remoteUserId];
                
                // Remove audio element
                const audioEl = document.getElementById(`audio-${remoteUserId}`);
                if (audioEl) audioEl.remove();
            }
        });

        // Handle incoming offer
        socket.on('webrtc_offer', async (data) => {
            const { sender, offer, target } = data;
            
            // Ignore if not in call, or if we're the sender, or if we're not the target
            if (!isInCall) return;
            if (sender === userId) return;
            if (target && target !== userId) return;
            
            console.log('Received offer from:', sender);
            
            // Close existing peer connection if any (renegotiation)
            if (peers[sender]) {
                peers[sender].close();
            }
            
            const peer = createPeerConnection(sender);
            peers[sender] = peer;
            
            try {
                await peer.setRemoteDescription(new RTCSessionDescription(offer));
                
                // Add local tracks if we have a stream (speaker mode)
                if (localStream) {
                    localStream.getTracks().forEach(track => peer.addTrack(track, localStream));
                }
                
                // Create answer - always do this to complete the connection
                // This allows us to receive audio even if we're not sending
                const answer = await peer.createAnswer();
                await peer.setLocalDescription(answer);
                
                socket.emit('webrtc_answer', {
                    room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                    target: sender,
                    sender: userId,
                    answer: answer
                });
            } catch (e) {
                console.error('Error handling offer:', e);
            }
        });

        // Handle incoming answer
        socket.on('webrtc_answer', async (data) => {
            const { sender, answer, target } = data;
            
            // Ignore if not in call or not the intended target
            if (!isInCall) return;
            if (target && target !== userId) return;
            
            const peer = peers[sender];
            
            if (peer) {
                try {
                    // Only set remote description if we haven't already
                    if (peer.signalingState === 'have-local-offer') {
                        await peer.setRemoteDescription(new RTCSessionDescription(answer));
                    }
                } catch (e) {
                    console.error('Error setting remote description:', e);
                }
            }
        });

        // Handle ICE candidate
        socket.on('webrtc_ice', async (data) => {
            const { sender, candidate, target } = data;
            
            // Ignore if not in call or not the intended target
            if (!isInCall) return;
            if (target && target !== userId) return;
            
            const peer = peers[sender];
            
            if (peer && peer.remoteDescription) {
                try {
                    await peer.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            }
        });

        function createPeerConnection(remoteUserId) {
            const peer = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });
            
            peer.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('webrtc_ice', {
                        room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard',
                        target: remoteUserId,
                        sender: userId,
                        candidate: event.candidate
                    });
                }
            };
            
            peer.ontrack = (event) => {
                console.log('Received track from:', remoteUserId);
                let audioEl = document.getElementById(`audio-${remoteUserId}`);
                if (!audioEl) {
                    audioEl = document.createElement('audio');
                    audioEl.id = `audio-${remoteUserId}`;
                    audioEl.autoplay = true;
                    participantsEl.appendChild(audioEl);
                }
                audioEl.srcObject = event.streams[0];
            };
            
            return peer;
        }

        // Join room
        socket.emit('join_room', { room: sessionId ? `whiteboard:${sessionId}` : 'whiteboard', user_id: userId });

        // Fullscreen functionality for mobile
        let isFullscreen = false;
        let fullscreenControls = null;
        let fullscreenExitBtn = null;
        
        const fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
        
        function enterFullscreen() {
            if (!canvas) return;
            
            // Save canvas state before fullscreen transition
            saveCanvasState();
            
            isFullscreen = true;
            canvas.classList.add('whiteboard-fullscreen');
            
            // Create floating controls for fullscreen mode
            fullscreenControls = document.createElement('div');
            fullscreenControls.className = 'fullscreen-controls';
            fullscreenControls.innerHTML = `
                <button class="btn btn-outline-dark fs-color-btn" title="Color">
                    <input type="color" id="fsColorPicker" value="${colorPicker.value}" style="opacity:0;position:absolute;width:100%;height:100%;cursor:pointer;">
                    <i class="fas fa-palette"></i>
                </button>
                <button class="btn btn-outline-dark fs-brush-small" title="Small brush">
                    <i class="fas fa-circle" style="font-size:8px;"></i>
                </button>
                <button class="btn btn-outline-dark fs-brush-medium" title="Medium brush">
                    <i class="fas fa-circle" style="font-size:12px;"></i>
                </button>
                <button class="btn btn-outline-dark fs-brush-large" title="Large brush">
                    <i class="fas fa-circle" style="font-size:16px;"></i>
                </button>
                <button class="btn btn-outline-warning fs-undo-btn" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            `;
            document.body.appendChild(fullscreenControls);
            
            // Create exit button
            fullscreenExitBtn = document.createElement('button');
            fullscreenExitBtn.className = 'btn btn-secondary fullscreen-exit-btn';
            fullscreenExitBtn.innerHTML = '<i class="fas fa-compress"></i>';
            fullscreenExitBtn.title = 'Exit fullscreen';
            document.body.appendChild(fullscreenExitBtn);
            
            // Event listeners for fullscreen controls
            const fsColorInput = fullscreenControls.querySelector('#fsColorPicker');
            fsColorInput.addEventListener('input', (e) => {
                colorPicker.value = e.target.value;
            });
            
            fullscreenControls.querySelector('.fs-brush-small').addEventListener('click', () => {
                brushSize.value = 2;
                document.getElementById('sizeValue').textContent = '2';
            });
            
            fullscreenControls.querySelector('.fs-brush-medium').addEventListener('click', () => {
                brushSize.value = 6;
                document.getElementById('sizeValue').textContent = '6';
            });
            
            fullscreenControls.querySelector('.fs-brush-large').addEventListener('click', () => {
                brushSize.value = 12;
                document.getElementById('sizeValue').textContent = '12';
            });
            
            fullscreenControls.querySelector('.fs-undo-btn').addEventListener('click', () => {
                if (undoBtn) undoBtn.click();
            });
            
            fullscreenExitBtn.addEventListener('click', exitFullscreen);
            
            // Resize canvas to fill screen after transition
            setTimeout(() => {
                resizeCanvas(true);
            }, 50);
            
            // Hide body scroll
            document.body.style.overflow = 'hidden';
        }
        
        function exitFullscreen() {
            if (!canvas) return;
            
            // Save canvas state before exiting fullscreen
            saveCanvasState();
            
            isFullscreen = false;
            canvas.classList.remove('whiteboard-fullscreen');
            
            // Remove floating controls
            if (fullscreenControls) {
                fullscreenControls.remove();
                fullscreenControls = null;
            }
            if (fullscreenExitBtn) {
                fullscreenExitBtn.remove();
                fullscreenExitBtn = null;
            }
            
            // Restore body scroll
            document.body.style.overflow = '';
            
            // Resize canvas back to container size after transition
            setTimeout(() => {
                resizeCanvas(true);
            }, 50);
        }
        
        if (fullscreenToggleBtn) {
            fullscreenToggleBtn.addEventListener('click', () => {
                if (isFullscreen) {
                    exitFullscreen();
                } else {
                    enterFullscreen();
                }
            });
        }
        
        // Exit fullscreen on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                exitFullscreen();
            }
        });

            // Create/Join session UI handlers
            const createSessionBtnMobile = document.getElementById('createSessionBtn');
            const joinSessionBtnMobile = document.getElementById('joinSessionBtn');
            const createSessionBtnDesktop = document.getElementById('createSessionBtnDesktop');
            const joinSessionBtnDesktop = document.getElementById('joinSessionBtnDesktop');
            
            const createModalEl = document.getElementById('createSessionModal');
            const joinModalEl = document.getElementById('joinSessionModal');
            
            console.log('Modal elements exist:', !!createModalEl, !!joinModalEl);
            
            let createModal = null;
            let joinModal = null;
            
            if (createModalEl) {
                createModal = new bootstrap.Modal(createModalEl);
            }
            if (joinModalEl) {
                joinModal = new bootstrap.Modal(joinModalEl);
            }
            
            const toggleDrawingToolsBtn = document.getElementById('toggleDrawingTools');
            const drawingToolsCollapseEl = document.getElementById('drawingToolsCollapse');
            console.log('toggleDrawingToolsBtn:', !!toggleDrawingToolsBtn, 'drawingToolsCollapseEl:', !!drawingToolsCollapseEl);
            if (toggleDrawingToolsBtn && drawingToolsCollapseEl) {
                drawingToolsCollapseEl.addEventListener('shown.bs.collapse', () => { toggleDrawingToolsBtn.textContent = 'Hide Tools'; });
                drawingToolsCollapseEl.addEventListener('hidden.bs.collapse', () => { toggleDrawingToolsBtn.textContent = 'Show Tools'; });
            }
            console.log('createSessionBtnDesktop exists?', !!createSessionBtnDesktop, 'joinSessionBtnDesktop exists?', !!joinSessionBtnDesktop);
            const openCreateModal = async (e) => { 
                if (e) e.preventDefault();
                console.log('openCreateModal called');
                if (!createModal) {
                    console.error('Create modal not initialized');
                    return;
                }
                try {
                    const grpRes = await fetch('/api/users/groups', { headers: { 'Authorization': `Bearer ${token}` } });
                    if (grpRes.ok) {
                        const d = await grpRes.json();
                        // Filter groups where user is owner
                        const groups = (d.data.groups || []).filter(g => g.owner_id === userId);
                        
                        if (groups.length === 0) {
                            alert('You must be a group owner to create a session.');
                            return;
                        }
                        
                        // Always show modal to allow naming the session
                        const select = document.getElementById('sessionGroupSelect');
                        select.innerHTML = '<option value="">Select a group</option>' + (groups.map(g => `<option value="${g.id}">${g.name}</option>`).join(''));
                        
                        if (groups.length === 1) {
                            // Pre-select the single group
                            select.value = groups[0].id;
                        }
                        createModal.show();
                    }
                } catch (e) {
                    console.error('Failed to load groups', e);
                }
            };

            async function createSession(groupId, title) {
                try {
                    const res = await fetch(`/api/groups/${groupId}/whiteboards`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ title: title || 'Whiteboard Session ' + new Date().toLocaleTimeString() })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        const invite = data.data.invite_url;
                        const fullUrl = window.location.origin + invite;
                        
                        document.getElementById('createdSessionLink').value = fullUrl;
                        document.getElementById('goToSessionBtn').onclick = () => window.location.href = invite;
                        new bootstrap.Modal(document.getElementById('sessionCreatedModal')).show();
                        createModal.hide();
                    } else {
                        const data = await res.json();
                        alert(data.message || 'Failed to create session');
                    }
                } catch (e) {
                    console.error('Failed to create session', e);
                    alert('Error creating session');
                }
            }
            createSessionBtnMobile && createSessionBtnMobile.addEventListener('click', openCreateModal);
            // createSessionBtnDesktop removed from DOM, using landing button
            const createSessionBtnLanding = document.getElementById('createSessionBtnLanding');
            if (createSessionBtnLanding) {
                createSessionBtnLanding.addEventListener('click', openCreateModal);
                console.log('Create session button listener attached');
            } else {
                console.log('createSessionBtnLanding not found');
            }

            // Preload user's groups into the create modal select (don't auto-open modal)
            (async function preloadGroups() {
                try {
                    const grpRes = await fetch('/api/users/groups', { headers: { 'Authorization': `Bearer ${token}` } });
                    if (grpRes.ok) {
                        const d = await grpRes.json();
                        const groups = d.data.groups || [];
                        const select = document.getElementById('sessionGroupSelect');
                        if (select) {
                            select.innerHTML = '<option value="">Select a group</option>' + (groups.map(g => `<option value="${g.id}">${g.name}</option>`).join(''));
                        }
                    }
                } catch (e) {
                    console.error('Failed to preload groups', e);
                }
            })();
            const openJoinModal = (e) => { 
                if (e) e.preventDefault();
                console.log('openJoinModal called');
                if (!joinModal) {
                    console.error('Join modal not initialized');
                    return;
                }
                joinModal.show(); 
            };
            joinSessionBtnMobile && joinSessionBtnMobile.addEventListener('click', openJoinModal);
            // joinSessionBtnDesktop removed from DOM, using landing button
            const joinSessionBtnLanding = document.getElementById('joinSessionBtnLanding');
            if (joinSessionBtnLanding) {
                joinSessionBtnLanding.addEventListener('click', openJoinModal);
                console.log('Join session button listener attached');
            }

            const createSubmitBtn = document.getElementById('createSessionSubmit');
            if (createSubmitBtn) {
                createSubmitBtn.addEventListener('click', async () => {
                    const gid = document.getElementById('sessionGroupSelect').value;
                    const title = document.getElementById('sessionNameInput').value.trim();
                    if (!gid) {
                        alert('Please select a group');
                        return;
                    }
                    createSession(gid, title);
                });
            }

            const joinSubmitBtn = document.getElementById('joinSessionSubmit');
            if (joinSubmitBtn) {
                joinSubmitBtn.addEventListener('click', () => {
                    const raw = document.getElementById('joinSessionId').value.trim();
                    if (!raw) return;
                    // Support full URL or plain session id
                    let id = raw;
                    try {
                        const url = new URL(raw);
                        const params = new URLSearchParams(url.search);
                        id = params.get('session') || id;
                    } catch (e) { /* not a URL */ }
                    if (!id) return;
                    window.location.href = `/whiteboard?session=${encodeURIComponent(id)}`;
                });
            }

            // Load my active sessions
            async function loadMySessions() {
                try {
                    const res = await fetch('/api/whiteboards/mine', { headers: { 'Authorization': `Bearer ${token}` } });
                    if (res.ok) {
                        const data = await res.json();
                        const sessions = data.data.whiteboards || [];
                        // Updated IDs for landing view
                        const list = document.getElementById('mySessionsListLanding');
                        const card = document.getElementById('mySessionsCardLanding');
                        
                        if (list && card) {
                            if (sessions.length > 0) {
                                card.style.display = 'block';
                                list.innerHTML = '';
                                sessions.forEach(s => {
                                    const item = document.createElement('div');
                                    item.className = 'list-group-item d-flex justify-content-between align-items-center';
                                    item.innerHTML = `
                                        <div>
                                            <div class="fw-bold text-truncate" style="max-width: 150px;">${s.title || 'Untitled'}</div>
                                            <small class="text-muted">${s.group_name}</small>
                                        </div>
                                        <div class="btn-group btn-group-sm">
                                            <a href="/whiteboard?session=${s.id}" class="btn btn-outline-primary">Join</a>
                                            <button class="btn btn-outline-danger end-session-btn" data-id="${s.id}">End</button>
                                        </div>
                                    `;
                                    list.appendChild(item);
                                });
                                
                                // Add event listeners for end buttons
                                document.querySelectorAll('.end-session-btn').forEach(btn => {
                                    btn.addEventListener('click', async (e) => {
                                        e.preventDefault();
                                        const id = e.target.getAttribute('data-id');
                                        if (confirm('Are you sure you want to end this session? It will be closed for everyone.')) {
                                            await endSession(id);
                                        }
                                    });
                                });
                            } else {
                                card.style.display = 'none';
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to load my sessions', e);
                }
            }
            
            async function endSession(id) {
                try {
                    const res = await fetch(`/api/whiteboards/${id}`, { 
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${token}` } 
                    });
                    if (res.ok) {
                        loadMySessions(); // Refresh list
                        if (sessionId === id) {
                            alert('Session ended');
                            window.location.href = '/whiteboard';
                        }
                    } else {
                        alert('Failed to end session');
                    }
                } catch (e) {
                    console.error('Failed to end session', e);
                }
            }
            
            loadMySessions();
            // Refresh list periodically
            setInterval(loadMySessions, 30000);
    })();
</script>
{% endblock %}