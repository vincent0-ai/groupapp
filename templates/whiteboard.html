{% extends "base.html" %}

{% block title %}Whiteboard - Discussio{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.2.0/dist/livekit-client.umd.min.js"></script>
<style>
    canvas {
        border: 2px solid var(--border-color);
        background: #fff;
        cursor: crosshair;
        border-radius: 8px;
        touch-action: none;
    }

    .controls {
        margin-bottom: 15px;
    }

    /* Fullscreen mode styles */
    .whiteboard-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
        background: #fff !important;
        border-radius: 0 !important;
        border: none !important;
    }

    .fullscreen-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        display: flex;
        gap: 10px;
        background: rgba(255,255,255,0.95);
        padding: 10px 15px;
        border-radius: 30px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    .fullscreen-controls button {
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .fullscreen-exit-btn {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10000;
        border-radius: 50%;
        width: 45px;
        height: 45px;
    }

    /* Always show fullscreen toggle (desktop & mobile) */
    .fullscreen-toggle-btn {
        display: inline-flex !important;
    }

    /* Mobile Controls Bar */
    @media (max-width: 991px) {
        #sessionControls {
            position: fixed;
            top: 56px; /* Approximate navbar height */
            left: 0;
            width: 100%;
            z-index: 1020;
            background: white;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-bottom: 1px solid var(--border-color);
            /* keep controls on a single horizontal line and allow scrolling */
            flex-wrap: nowrap !important;
            overflow-x: auto;
            justify-content: flex-start;
            border-radius: 0 !important;
            border: none !important;
            border-bottom: 1px solid var(--border-color) !important;
        }
        
        #sessionControls::-webkit-scrollbar {
            display: none;
        }
        
        #sessionView {
            margin-top: 60px !important;
        }

        /* Prevent buttons from wrapping into vertical / stacked text on certain mobile browsers */
        #sessionControls, #sessionControls * {
            -webkit-overflow-scrolling: touch;
            white-space: nowrap !important;
            writing-mode: horizontal-tb !important;
        }

        #sessionControls .btn {
            flex: 0 0 auto !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 6px;
        }

        /* Compact icon-only mode for very narrow screens */
        @media (max-width: 420px) {
            #sessionControls {
                padding: 8px 10px;
            }
            #sessionControls .btn {
                padding: 0 !important;
                width: 44px !important;
                height: 44px !important;
                border-radius: 50% !important;
                justify-content: center !important;
                font-size: 0; /* hide stray text nodes if any */
            }
            #sessionControls .btn .btn-text { display: none !important; }
            #sessionControls .btn i { font-size: 1.05rem !important; }
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Page Header -->
<div class="page-header mb-4" style="background: var(--gradient-primary); border-radius: 20px; padding: 2rem; color: white;">
    <div class="d-flex align-items-center gap-3">
        <div>
            <h1 class="mb-1" style="font-size: 1.75rem; font-weight: 700;">Collaborate</h1>
            <p class="mb-0 opacity-75">Draw and collaborate in real-time with your group</p>
        </div>
    </div>
</div>

<!-- Landing View -->
<div id="landingView" style="display:none;">
    <div class="row mt-4">
        <div class="col-md-8 offset-md-2">
            <div class="card shadow-sm border-0 mb-4" style="overflow: hidden;">
                <div class="card-body text-center p-5" style="background: var(--primary-ultra-light);">
                    <p class="text-muted mb-4">Create a new whiteboard session or join an existing one</p>
                    <div class="d-flex justify-content-center gap-3 flex-wrap">
                        <button id="createSessionBtnLanding" class="btn btn-primary btn-lg px-4">
                            <i class="fas fa-plus-circle me-2"></i> Create Session
                        </button>
                        <button id="joinSessionBtnLanding" class="btn btn-outline-primary btn-lg px-4">
                            <i class="fas fa-sign-in-alt me-2"></i> Join Session
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="card shadow-sm border-0" id="mySessionsCardLanding" style="display:none;">
                <div class="card-header" style="background: transparent; border-bottom: 1px solid var(--border-color);">
                    <h5 class="mb-0"><i class="fas fa-list text-primary me-2"></i> My Active Sessions</h5>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush" id="mySessionsListLanding">
                        <!-- Sessions will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Session View -->
<div id="sessionView" class="row mt-4" style="display:none;">
    <!-- Top Controls Bar -->
    <div class="col-12 mb-3">
        <div id="sessionControls" class="d-flex flex-wrap gap-2 align-items-center p-3 bg-white rounded shadow-sm border"></div>
    </div>

    <div class="col-lg-2">
        <div class="card shadow-sm border-0 mb-3" style="overflow: hidden;">
            <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="card-title mb-0 fw-semibold"><i class="fas fa-paint-brush text-primary me-2"></i>Tools</h6>
                        <button class="btn btn-sm btn-outline-primary" data-bs-toggle="collapse" data-bs-target="#drawingToolsCollapse" aria-expanded="false" aria-controls="drawingToolsCollapse" id="toggleDrawingTools" style="font-size: 0.75rem;">Show</button>
                    </div>
                    <div id="permissionStatus" class="mb-2 text-muted small mt-2"></div>
                    <div class="collapse" id="drawingToolsCollapse">
                        <div class="controls mb-3 mt-3">
                            <label for="colorPicker" class="form-label small fw-medium">Color</label>
                            <input type="color" class="form-control form-control-color w-100" id="colorPicker" value="#000000" style="height: 40px; border-radius: 10px;">
                        </div>
                        <div class="controls mb-3">
                            <label for="brushSize" class="form-label small fw-medium">Brush Size: <span id="sizeValue" class="badge bg-primary">3</span>px</label>
                            <input type="range" class="form-range" id="brushSize" min="1" max="20" value="3">
                        </div>
                        <div class="controls mb-3">
                            <label for="opacity" class="form-label small fw-medium">Opacity</label>
                            <input type="range" class="form-range" id="opacity" min="0" max="1" step="0.1" value="1">
                        </div>
                        <div class="btn-group-vertical w-100 gap-2">
                            <button id="clearBtn" class="btn btn-warning">
                                <i class="fas fa-trash me-1"></i> Clear
                            </button>
                            <button id="undoBtn" class="btn btn-outline-secondary">
                                <i class="fas fa-undo me-1"></i> Undo
                            </button>
                            <button id="downloadBtn" class="btn btn-info text-white">
                                <i class="fas fa-download me-1"></i> Save
                            </button>
                        </div>
                    </div>
                    <div class="d-grid mt-3" id="leaveSessionContainer">
                        <a href="/whiteboard" class="btn btn-sm btn-outline-danger"><i class="fas fa-sign-out-alt me-1"></i>Leave</a>
                    </div>
            </div>
        </div>

        <div class="card mt-3 shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header" style="background: rgba(79, 70, 229, 0.08); border-bottom: none;">
                <h6 class="mb-0 fw-semibold"><i class="fas fa-users text-primary me-2"></i> Participants</h6>
            </div>
            <div class="card-body">
                <div id="participantsList" style="max-height: 30vh; overflow-y: auto;">
                    <small class="text-body-secondary">Connecting...</small>
                </div>
                <div id="inviteLinkContainer" class="mt-3 border-top pt-2"></div>
                <div id="audioFilesContainer" class="mt-3 border-top pt-2"></div>
            </div>
        </div>
    </div>

    <div class="col-lg-10">
        <div class="card shadow-sm border-0" style="overflow: hidden;">
            <div class="card-header d-flex justify-content-between align-items-center" style="background: rgba(79, 70, 229, 0.08); border-bottom: none;">
                <span class="fw-semibold"><i class="fas fa-chalkboard text-primary me-2"></i>Whiteboard</span>
                <button id="fullscreenToggleBtn" class="btn btn-sm btn-primary fullscreen-toggle-btn">
                    <i class="fas fa-expand me-1"></i> Fullscreen
                </button>
            </div>
            <div class="card-body overflow-auto text-center" id="canvasContainer" style="background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%); padding: 1rem;">
                <div style="position:relative; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                    <canvas id="whiteboard" style="width:100%;height:50vh;display:block; background: white;" width="1200" height="600"></canvas>
                    <div id="canvasOverlay" style="position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,0.85); backdrop-filter: blur(4px);">
                        <div class="text-muted"><i class="fas fa-lock me-2"></i>You don't have permission to draw in this session</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Remote Video Container (Screen Share) -->
<div id="remoteVideoContainer" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; flex-direction: column;">
    <div class="d-flex w-100 justify-content-end p-3" style="position: absolute; top: 0; right: 0;">
        <button id="fullscreenBtn" class="btn btn-outline-light rounded-circle me-2" title="Toggle Fullscreen"><i class="fas fa-expand"></i></button>
        <button class="btn btn-outline-light rounded-circle" onclick="document.getElementById('remoteVideoContainer').style.display='none'" title="Close Video"><i class="fas fa-times"></i></button>
    </div>
    <video id="remoteVideo" autoplay playsinline controls style="max-width: 95%; max-height: 90%; border-radius: 8px; box-shadow: 0 0 20px rgba(0,0,0,0.5);"></video>
    <div id="remoteVideoLabel" class="text-white mt-2 fw-bold fs-5"></div>
</div>
{% endblock %}

{% block modals %}
<!-- Create/Join Session Modals -->
<!-- Create Session Modal -->
<div class="modal fade" id="createSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-plus-circle me-2"></i>Create Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="text-muted mb-3">Select which group this session is for:</p>
                <div class="mb-3">
                    <label for="sessionGroupSelect" class="form-label fw-medium">Group</label>
                    <select id="sessionGroupSelect" class="form-select" style="border-radius: 10px;"></select>
                </div>
                <div class="mb-3">
                    <label for="sessionNameInput" class="form-label fw-medium">Session Name</label>
                    <input type="text" class="form-control" id="sessionNameInput" placeholder="Enter session name (optional)" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="createSessionSubmit" type="button" class="btn btn-primary">Create Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Session Created Modal -->
<div class="modal fade" id="sessionCreatedModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-success); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-check-circle me-2"></i>Session Created</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <p class="mb-3">Share this link with your group members:</p>
                <div class="input-group">
                    <input type="text" class="form-control" id="createdSessionLink" readonly style="border-radius: 10px 0 0 10px;">
                    <button class="btn btn-primary" type="button" onclick="navigator.clipboard.writeText(document.getElementById('createdSessionLink').value); this.innerHTML='<i class=\'fas fa-check\'></i>'; setTimeout(()=>this.innerHTML='<i class=\'fas fa-copy\'></i>', 2000);" style="border-radius: 0 10px 10px 0;"><i class="fas fa-copy"></i></button>
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
                <button id="goToSessionBtn" type="button" class="btn btn-primary"><i class="fas fa-arrow-right me-1"></i>Go to Session</button>
            </div>
        </div>
    </div>
</div>

<!-- Join Session Modal -->
<div class="modal fade" id="joinSessionModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-0" style="border-radius: 20px; overflow: hidden;">
            <div class="modal-header" style="background: var(--gradient-primary); border-bottom: none;">
                <h5 class="modal-title text-white fw-semibold"><i class="fas fa-sign-in-alt me-2"></i>Join Session</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body p-4">
                <div class="mb-3">
                    <label class="form-label fw-medium">Session ID</label>
                    <input id="joinSessionId" class="form-control" placeholder="Enter session ID or paste invite link" style="border-radius: 10px;">
                </div>
            </div>
            <div class="modal-footer border-0 pt-0">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button id="joinSessionSubmit" type="button" class="btn btn-primary"><i class="fas fa-sign-in-alt me-1"></i>Join</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    (() => {
        const token = localStorage.getItem('token');
        const userId = localStorage.getItem('userId');

        if (!token || !userId) {
            sessionStorage.setItem('redirectAfterLogin', window.location.href);
            window.location.href = "{{ url_for('auth_page') }}";
            return;
        }

        // --- DOM Elements ---
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const sessionId = new URLSearchParams(window.location.search).get('session');
        const participantsEl = document.getElementById('participantsList');
        const landingView = document.getElementById('landingView');
        const sessionView = document.getElementById('sessionView');
        const controlsContainer = document.getElementById('sessionControls');
        const remoteVideoContainer = document.getElementById('remoteVideoContainer');
        const remoteVideoEl = document.getElementById('remoteVideo');
        const remoteVideoLabel = document.getElementById('remoteVideoLabel');
        const participantsAudioContainer = document.createElement('div');
        participantsAudioContainer.id = 'participantsAudioContainer';

        // --- LiveKit Service ---
        class MediaService {
            constructor() {
                this.room = null;
                this.onTrackSubscribed = null;
                this.onTrackUnsubscribed = null;
                this.onParticipantDisconnected = null;
                this.onConnectionStateChange = null;
            }

            async connect(token, url) {
                this.room = new LivekitClient.Room({
                    audioCaptureDefaults: {
                        autoGainControl: true,
                        echoCancellation: true,
                        noiseSuppression: true,
                        channelCount: 1, // Mono audio
                    },
                    videoCaptureDefaults: {
                        resolution: LivekitClient.VideoPresets.h720.resolution,
                    },
                    publishDefaults: {
                        audioBitrate: 20000, // 20kbps
                        videoCodec: 'vp8',
                        simulcast: false, // Disabled for free tier
                        videoEncoding: { maxBitrate: 1_500_000, maxFramerate: 30 },
                    },
                    adaptiveStream: true,
                });

                await this.room.connect(url, token);

                this.room
                    .on(LivekitClient.RoomEvent.TrackSubscribed, (t, p, participant) => this.onTrackSubscribed?.(t, participant))
                    .on(LivekitClient.RoomEvent.TrackUnsubscribed, (t, p, participant) => this.onTrackUnsubscribed?.(t, participant))
                    .on(LivekitClient.RoomEvent.ParticipantDisconnected, (p) => this.onParticipantDisconnected?.(p))
                    .on(LivekitClient.RoomEvent.ConnectionStateChanged, (state) => this.onConnectionStateChange?.(state));
                
                console.log('Connected to LiveKit room:', this.room.name);
                return this.room;
            }

            async disconnect() {
                if (this.room) {
                    await this.room.disconnect();
                    this.room = null;
                    console.log('Disconnected from LiveKit room.');
                }
            }

            async publishAudio(enabled) {
                if (!this.room?.localParticipant) {
                    console.debug('[MediaService] publishAudio called but no localParticipant', enabled);
                    return;
                }
                console.debug('[MediaService] publishAudio ->', enabled);
                try {
                    const res = await this.room.localParticipant.setMicrophoneEnabled(enabled);
                    console.debug('[MediaService] publishAudio result ->', res);
                    return res;
                } catch (e) {
                    console.error('[MediaService] publishAudio failed ->', e);
                    throw e;
                }
            }

            async publishScreenShare(enabled) {
                if (!this.room?.localParticipant) return;
                const screenShareOpts = { audio: false, selfBrowserSurface: "include" };
                return await this.room.localParticipant.setScreenShareEnabled(enabled, screenShareOpts);
            }
        }
        const mediaService = new MediaService();

        // --- Application State ---
        let isDrawing = false, lastX = 0, lastY = 0;
        let participants = {}, isCreator = false;
        let canDraw = true, canSpeak = true, canShareScreen = true;
        let isInCall = false, isMuted = false, isScreenSharing = false;
        // Track when a moderator forced a mute so we can allow auto-unmute when permission is restored
        let mutedByModerator = false;
        const socket = io();

        // --- Media Call Logic ---
        function setupMediaControls() {
            if (!sessionId || document.getElementById('liveBtn')) return;
            const liveBtn = document.createElement('button');
            liveBtn.id = 'liveBtn';
            liveBtn.className = 'btn btn-sm btn-outline-success';
            liveBtn.setAttribute('aria-label', 'Join Call');
            liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';

            const muteBtn = document.createElement('button');
            muteBtn.id = 'muteBtn';
            // Show mute button but disable until in-call; visibility communicates capability to users
            muteBtn.className = 'btn btn-sm btn-outline-warning';
            muteBtn.setAttribute('aria-label', 'Mute');
            muteBtn.disabled = true;
            muteBtn.innerHTML = '<i class="fas fa-microphone"></i><span class="btn-text"> Mute</span>';

            const screenShareBtn = document.createElement('button');
            screenShareBtn.id = 'screenShareBtn';
            // Show share button but disable until in-call; will enable only if permission allows
            screenShareBtn.className = 'btn btn-sm btn-outline-info';
            screenShareBtn.setAttribute('aria-label', 'Share Screen');
            screenShareBtn.disabled = true;
            screenShareBtn.innerHTML = '<i class="fas fa-desktop"></i><span class="btn-text"> Share Screen</span>';
            
            const watchScreenBtn = document.createElement('button');
            watchScreenBtn.id = 'watchScreenBtn';
            watchScreenBtn.className = 'btn btn-sm btn-outline-primary';
            watchScreenBtn.setAttribute('aria-label', 'Watch Screen');
            watchScreenBtn.disabled = true;
            watchScreenBtn.innerHTML = '<i class="fas fa-eye"></i><span class="btn-text"> Watch Screen</span>';

            const raiseBtn = document.createElement('button');
            raiseBtn.id = 'raiseBtn';
            raiseBtn.className = 'btn btn-sm btn-outline-secondary';
            raiseBtn.setAttribute('aria-label', 'Raise Hand');
            raiseBtn.innerHTML = '<i class="fas fa-hand-paper"></i><span class="btn-text"> Raise Hand</span>';

            const leaveSessionBtn = document.createElement('button');
            leaveSessionBtn.id = 'leaveSessionBtn';
            leaveSessionBtn.className = 'btn btn-sm btn-outline-danger';
            leaveSessionBtn.setAttribute('aria-label', 'Leave Session');
            leaveSessionBtn.innerHTML = '<i class="fas fa-sign-out-alt me-1"></i><span class="btn-text"> Leave</span>';


            controlsContainer.appendChild(liveBtn);
            controlsContainer.appendChild(muteBtn);
            controlsContainer.appendChild(screenShareBtn);
            controlsContainer.appendChild(watchScreenBtn);
            controlsContainer.appendChild(raiseBtn);
            controlsContainer.appendChild(leaveSessionBtn);

            watchScreenBtn.addEventListener('click', async () => {
                const remoteContainer = document.getElementById('remoteVideoContainer');
                if (!remoteContainer || remoteContainer.style.display === 'none') return showCustomAlert('No active screen share to watch.', 'Screen Share');
                try {
                    if (document.fullscreenElement && document.fullscreenElement !== remoteContainer) await document.exitFullscreen();
                    await remoteContainer.requestFullscreen();
                } catch (e) {
                    // fallback: toggle class if fullscreen API not available
                    remoteContainer.classList.toggle('whiteboard-fullscreen');
                }
            });
            liveBtn.addEventListener('click', () => isInCall ? leaveCall() : joinCall());
            muteBtn.addEventListener('click', async () => {
                // only allow toggling while connected
                if (!isInCall) return showCustomAlert('Join the call first to toggle microphone.', 'Not In Call');
                // If attempting to unmute but moderator revoked speak, prevent unmuting
                if (isMuted) {
                    // user is trying to unmute
                    if (!canSpeak) {
                        showCustomAlert('You have been muted by the moderator. You cannot unmute until permission is granted.', 'Muted');
                        return;
                    }
                }
                isMuted = !isMuted;
                console.debug('User toggled mute ->', isMuted ? 'muted' : 'unmuted');
                try { await mediaService.publishAudio(!isMuted); } catch (e) { console.error('Failed to toggle audio', e); }
                // If the user explicitly unmuted, clear moderator-forced flag
                if (!isMuted) mutedByModerator = false;
                updateMuteButton();
            });
            screenShareBtn.addEventListener('click', async () => {
                if (!isInCall) return showCustomAlert('Join the call first to share your screen.', 'Not In Call');
                // Only allow if server-side permission says user may share
                if (!canShareScreen) return showCustomAlert('You do not have permission to share your screen in this session.', 'Permission');
                isScreenSharing = !isScreenSharing;
                try {
                    await mediaService.publishScreenShare(isScreenSharing);
                } catch(e) {
                     console.error('Screen share failed:', e);
                     isScreenSharing = false;
                     showCustomAlert('Could not start screen sharing. Make sure you allowed the browser to share your screen.', 'Screen Share');
                }
                updateScreenShareButton();
            });
            raiseBtn.addEventListener('click', () => {
                 socket.emit('raise_hand', { room: `whiteboard:${sessionId}`, user_id: userId });
                 if(participants[userId]) participants[userId].raised = true;
                 renderParticipants();
            });

            // Hide left-column leave control (we provide a top-bar button now)
            try { document.getElementById('leaveSessionContainer').style.display = 'none'; } catch(e){}

            leaveSessionBtn.addEventListener('click', async () => {
                // If creator, confirm and end session; otherwise just leave
                if (isCreator) {
                    if (!confirm('End session for everyone?')) return;
                    await endSession(sessionId);
                    return;
                }
                // leave: ensure we disconnect from media and go back
                try { await leaveCall(); } catch(e){}
                window.location.href = '/whiteboard';
            });
        }

        function updateMuteButton() {
            const muteBtn = document.getElementById('muteBtn');
            if(!muteBtn) return;
            muteBtn.innerHTML = isMuted ? '<i class="fas fa-microphone-slash"></i><span class="btn-text"> Unmute</span>' : '<i class="fas fa-microphone"></i><span class="btn-text"> Mute</span>';
            muteBtn.className = isMuted ? 'btn btn-sm btn-warning' : 'btn btn-sm btn-outline-warning';
            // Disable when not in call or if attempting to unmute while moderator revoked speak
            muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
            // Update ARIA pressed for accessibility
            muteBtn.setAttribute('aria-pressed', String(!isMuted));
        }

        function updateScreenShareButton() {
            const screenShareBtn = document.getElementById('screenShareBtn');
            if(!screenShareBtn) return;
            screenShareBtn.innerHTML = isScreenSharing ? '<i class="fas fa-desktop"></i><span class="btn-text"> Stop Sharing</span>' : '<i class="fas fa-desktop"></i><span class="btn-text"> Share Screen</span>';
            screenShareBtn.className = isScreenSharing ? 'btn btn-sm btn-info text-white' : 'btn btn-sm btn-outline-info';
            screenShareBtn.disabled = !isInCall;
        }

        async function getLiveKitToken(lkSessionId) {
            try {
                const res = await fetch(`/api/whiteboards/${lkSessionId}/livekit-token`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const text = await res.text();
                let json = null;
                try { json = JSON.parse(text); } catch(e) { /* not JSON */ }
                if (!res.ok) {
                    console.error('LiveKit token endpoint error', res.status, text);
                    throw new Error((json && (json.message || json.error)) || text || 'Failed to get media token');
                }
                // return both token and optional url from server
                return { token: json?.data?.token || json?.token, url: json?.data?.url || json?.url };
            } catch (e) {
                console.error('getLiveKitToken failed:', e);
                showCustomAlert(e.message, 'Media Server Error');
                return null;
            }
        }

        // Resume/resume audio context to prime autoplay on browsers (fixes remote audio being blocked)
        async function primeAudio() {
            try {
                if (window.__audioPrimed) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtx) return;
                const ctx = new AudioCtx();
                // resume must be called from a user gesture - join button is a gesture
                await ctx.resume();
                // generate a silent burst so some browsers consider the audio system active
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                gain.gain.value = 0;
                osc.connect(gain).connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.01);
                window.__audioPrimed = true;
                // keep the context around so it doesn't get GC'd
                window.__audioContext = ctx;
            } catch (e) {
                console.warn('Audio priming failed', e);
            }
        }

        async function joinCall() {
            const liveBtn = document.getElementById('liveBtn');
            if (!liveBtn) return;
            
            liveBtn.disabled = true;
            liveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span class="btn-text"> Joining...</span>';
            const lkResp = await getLiveKitToken(sessionId);
            if (!lkResp || !lkResp.token) {
                liveBtn.disabled = false;
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
                return;
            }

            const lkToken = lkResp.token;
            // prefer server-provided URL, fallback to config placeholder
            const configured = lkResp.url || "{{ config.LIVEKIT_URL }}" || "http://localhost:7880";
            const wsUrl = String(configured).replace(/^http/, 'ws');

            try {
                // Prime audio system (must be run as a user gesture) to avoid browsers blocking remote audio playback
                await primeAudio();

                // If user is allowed to speak, proactively request microphone permission
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                } catch (permErr) {
                    console.warn('Microphone permission denied or unavailable', permErr);
                    showCustomAlert('Microphone access was denied. You will join muted.', 'Permission');
                }
                // MediaService.connect expects (token, url)
                await mediaService.connect(lkToken, wsUrl);
                isInCall = true;

                // Use our server-side permission flags (canSpeak / canShareScreen) to show controls.
                liveBtn.disabled = false;
                liveBtn.className = 'btn btn-sm btn-danger';
                liveBtn.innerHTML = '<i class="fas fa-phone-slash"></i><span class="btn-text"> Leave</span>';

                const muteBtn = document.getElementById('muteBtn');
                const screenShareBtn = document.getElementById('screenShareBtn');

                // If we can speak, unmute by default
                if (canSpeak) {
                    isMuted = false;
                    try { await mediaService.publishAudio(true); console.debug('Auto-enabled mic for user (canSpeak)'); } catch(e) { console.warn('Auto-enable mic failed', e); }
                } else {
                    // even if user cant speak to OTHERS, we can still publish audio
                    // so they can hear themselves. They will be hidden from others.
                    isMuted = false; 
                    try { await mediaService.publishAudio(true); console.debug('Auto-enabled mic for user (no canSpeak)'); } catch(e) { console.warn('Auto-enable mic failed', e); }
                }
                updateMuteButton();

            } catch (e) {
                console.error('Failed to join LiveKit call:', e);
                showCustomAlert('Could not connect to the media session.', 'Connection Error');
                isInCall = false;
                liveBtn.disabled = false;
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
            }
        }

        async function leaveCall() {
            await mediaService.disconnect();
            isInCall = false;
            isScreenSharing = false;

            const liveBtn = document.getElementById('liveBtn');
            if(liveBtn) {
                liveBtn.className = 'btn btn-sm btn-outline-success';
                liveBtn.innerHTML = '<i class="fas fa-phone"></i><span class="btn-text"> Join Call</span>';
            }
            document.getElementById('muteBtn')?.classList.add('d-none');
            // Disable media buttons when leaving
            const muteBtn = document.getElementById('muteBtn');
            const screenShareBtn = document.getElementById('screenShareBtn');
            if (muteBtn) { muteBtn.disabled = true; }
            if (screenShareBtn) { screenShareBtn.disabled = true; }
            
            remoteVideoContainer.style.display = 'none';
            try { document.getElementById('watchScreenBtn')?.setAttribute('disabled', 'true'); } catch(e){}
            if(remoteVideoEl) remoteVideoEl.srcObject = null;
            participantsAudioContainer.innerHTML = '';
        }

        mediaService.onTrackSubscribed = (track, participant) => {
            // For video tracks (screen share), attach to the existing <video> element
            // instead of inserting a nested video element. This avoids nested
            // <video> tags which can prevent playback for remote viewers.
            if (track.kind === 'video') {
                remoteVideoContainer.style.display = 'flex';
                try {
                    // Attach directly to the dedicated video element
                    track.attach(remoteVideoEl);
                    // Ensure playback attributes are present
                    remoteVideoEl.muted = false;
                    remoteVideoEl.controls = true;
                    remoteVideoEl.autoplay = true;
                    remoteVideoLabel.textContent = `${participant.name || participant.identity}'s screen`;
                } catch (e) {
                    // Fallback: create element returned by attach()
                    const el = track.attach();
                    remoteVideoEl.replaceChildren(el);
                    remoteVideoLabel.textContent = `${participant.name || participant.identity}'s screen`;
                }
                // Enable "Watch Screen" control when a remote screen share is active
                try { document.getElementById('watchScreenBtn')?.removeAttribute('disabled'); } catch(e){}
                
            } else if (track.kind === 'audio') {
                console.debug('[Media] audio track subscribed from', participant.identity);
                const el = track.attach();
                // Ensure audio elements are configured to play immediately
                // where browsers allow it (helps avoid one-way audio issues).
                el.id = `audio-${participant.identity}`;
                el.autoplay = true;
                el.playsInline = true;
                el.controls = false;
                el.muted = false;
                participantsAudioContainer.appendChild(el);
                // Attempt to start playback (may require user gesture in some browsers)
                try { el.play().catch(() => { console.debug('Playback prevented by browser autoplay policy'); }); } catch (e) { /* ignore */ }
            }
        };

        mediaService.onTrackUnsubscribed = (track, participant) => {
            if (track.kind === 'video') {
                // Stop and clear the primary video element instead of removing it
                if (remoteVideoEl) {
                    try {
                        remoteVideoEl.pause();
                        remoteVideoEl.srcObject = null;
                        // Remove any fallback child nodes if present
                        remoteVideoEl.replaceChildren();
                    } catch (e) { /* ignore DOM errors */ }
                }
                remoteVideoContainer.style.display = 'none';
                remoteVideoLabel.textContent = '';
                // Disable "Watch Screen" control when remote share ends
                try { document.getElementById('watchScreenBtn')?.setAttribute('disabled', 'true'); } catch(e){}
            }
            // Remove detached elements that are not the main video element
            track.detach().forEach(el => { if (el && el !== remoteVideoEl) el.remove(); });
            // Also remove any managed audio element for this participant
            try { document.getElementById(`audio-${participant.identity}`)?.remove(); } catch(e){}
        };

        mediaService.onParticipantDisconnected = (participant) => {
            document.getElementById(`audio-${participant.identity}`)?.remove();
        };
        
        mediaService.onConnectionStateChange = (state) => {
            if (state === LivekitClient.ConnectionState.Disconnected) {
                // Handle unexpected disconnects
                if (isInCall) {
                    leaveCall();
                    showCustomAlert('You have been disconnected from the media session.', 'Disconnected');
                }
            }
        };

        // --- Drawing and General UI Logic ---
        // (All drawing, canvas, and modal logic remains here, unchanged)
        
        // --- Init and Socket Handlers ---
        
        if (sessionId) {
            landingView.style.display = 'none';
            sessionView.style.display = 'flex';
            setupMediaControls();
        } else {
            landingView.style.display = 'block';
            sessionView.style.display = 'none';
            // Load user's active sessions for quick access
            try { loadMySessions(); } catch(e) { console.warn('loadMySessions unavailable yet'); }
        }
        
        async function loadSessionInfo() {
             if (!sessionId) return;
            try {
                const res = await fetch(`/api/whiteboards/${sessionId}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (res.status >= 400) {
                    await showCustomAlert((await res.json()).message || 'Session not found', 'Error');
                    window.location.href = '/whiteboard';
                    return;
                }
                const data = await res.json();
                const wb = data.data;

                if (wb.title) {
                    document.querySelector('h1').textContent = wb.title;
                    document.title = `${wb.title} - Discussio`;
                }

                isCreator = wb.created_by === userId;
                // Update top-bar leave button depending on creator status
                const leaveBtn = document.getElementById('leaveSessionBtn');
                if (leaveBtn) {
                    if (isCreator) {
                        leaveBtn.setAttribute('aria-label', 'End Session');
                        leaveBtn.innerHTML = '<i class="fas fa-stop-circle me-1"></i><span class="btn-text"> End Session</span>';
                        leaveBtn.className = 'btn btn-sm btn-danger';
                        leaveBtn.onclick = async () => { if (confirm('End session for everyone?')) await endSession(sessionId); };
                    } else {
                        leaveBtn.setAttribute('aria-label', 'Leave');
                        leaveBtn.innerHTML = '<i class="fas fa-sign-out-alt me-1"></i><span class="btn-text"> Leave</span>';
                        leaveBtn.className = 'btn btn-sm btn-outline-danger';
                        leaveBtn.onclick = async () => { try { await leaveCall(); } catch(e){}; window.location.href = '/whiteboard'; };
                    }
                }

                participants = (wb.participants || []).reduce((acc, p) => {
                    const uid = p.id || p._id;
                    acc[uid] = { name: p.username || p.full_name || `User ${String(uid).substr(-4)}`, avatar_url: p.avatar_url || '', can_draw: (wb.can_draw || []).map(String).includes(String(uid)), can_speak: (wb.can_speak || []).map(String).includes(String(uid)), can_share_screen: (wb.can_share_screen || []).map(String).includes(String(uid)) };
                    return acc;
                }, {});
                
                canDraw = isCreator || (wb.can_draw || []).map(String).includes(userId);
                canSpeak = isCreator || (wb.can_speak || []).map(String).includes(userId);
                canShareScreen = isCreator || (wb.can_share_screen || []).map(String).includes(userId);

                updatePermissionUI();
                renderParticipants();
                if (wb.drawing_data) {
                    wb.drawing_data.forEach(d => {
                        // Support both legacy absolute coords and newer normalized coords
                        let x0 = d.x0, y0 = d.y0, x1 = d.x1, y1 = d.y1;
                        if (d.normalized) {
                            x0 = d.x0 * canvas.clientWidth;
                            y0 = d.y0 * canvas.clientHeight;
                            x1 = d.x1 * canvas.clientWidth;
                            y1 = d.y1 * canvas.clientHeight;
                        }
                        draw(x0, y0, x1, y1, d.color, d.size, d.opacity);
                    });
                }
            } catch (e) { console.error('Failed to fetch session info', e); }
        }

        function renderParticipants() {
            if(!participantsEl) return;
            // Debug: log participant count and ids to help diagnose missing entries
            try { console.debug('renderParticipants: count=', Object.keys(participants).length, 'ids=', Object.keys(participants)); } catch (e) {}
            const content = Object.entries(participants).map(([uid, meta]) => {
                const avatarSrc = meta.avatar_url || `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(meta.name || uid)}`;
                let moderatorControls = '';
                if(isCreator && uid !== userId) {
                   moderatorControls = `
                    <button class="btn btn-xs mod-btn ${meta.can_draw ? 'btn-primary' : 'btn-outline-primary'}" data-action="${meta.can_draw ? 'revoke_draw' : 'grant_draw'}" data-uid="${uid}" title="${meta.can_draw ? 'Revoke' : 'Grant'} Draw"><i class="fas fa-pencil-alt"></i></button>
                    <button class="btn btn-xs mod-btn ${meta.can_speak ? 'btn-success' : 'btn-outline-secondary'}" data-action="${meta.can_speak ? 'revoke_speak' : 'grant_speak'}" data-uid="${uid}" title="${meta.can_speak ? 'Revoke' : 'Grant'} Speak"><i class="fas fa-microphone"></i></button>
                    <button class="btn btn-xs mod-btn ${meta.can_share_screen ? 'btn-info' : 'btn-outline-info'}" data-action="${meta.can_share_screen ? 'revoke_screen_share' : 'grant_screen_share'}" data-uid="${uid}" title="${meta.can_share_screen ? 'Revoke' : 'Grant'} Screen Share"><i class="fas fa-desktop"></i></button>
                    ${meta.raised ? `<button class="btn btn-xs mod-btn btn-outline-danger" data-action="clear_hand" data-uid="${uid}" title="Clear Hand"><i class="fas fa-hand-paper"></i></button>` : ''}
                `;
                } else {
                    moderatorControls = `<small class="text-muted">${meta.can_draw ? '✏️' : ''} ${meta.raised ? '✋' : ''}</small>`;
                }
                
                return `<div class="d-flex align-items-center justify-content-between mb-2">
                    <div class="d-flex align-items-center" style="min-width: 0;">
                        <img src="${avatarSrc}" class="rounded-circle me-2 flex-shrink-0" width="24" height="24"/>
                        <span class="small fw-medium text-truncate" title="${meta.name || uid}">${meta.name || uid}</span>
                    </div>
                    <div class="d-flex gap-1 flex-shrink-0 ms-1">${moderatorControls}</div>
                </div>`;
            }).join('');
            participantsEl.innerHTML = content;
            participantsEl.appendChild(participantsAudioContainer);

            // Attach event listeners to moderator buttons so they use the scoped `socket` variable
            participantsEl.querySelectorAll('.mod-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = btn.dataset.action;
                    const targetId = btn.dataset.uid;
                    if (!action || !targetId) return;
                    const payload = { room: `whiteboard:${sessionId}`, user_id: targetId, requester_id: userId };
                    // Optimistic UI update so moderator sees immediate feedback
                    try {
                        if (action === 'grant_draw') participants[targetId].can_draw = true;
                        if (action === 'revoke_draw') participants[targetId].can_draw = false;
                        if (action === 'grant_speak') participants[targetId].can_speak = true;
                        if (action === 'revoke_speak') participants[targetId].can_speak = false;
                        if (action === 'grant_screen_share') participants[targetId].can_share_screen = true;
                        if (action === 'revoke_screen_share') participants[targetId].can_share_screen = false;
                        renderParticipants();
                    } catch (e) { /* ignore optimistic errors */ }

                    // Visual affordance while waiting for the server to confirm
                    btn.disabled = true;
                    const prevHtml = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    if (action === 'clear_hand') {
                        socket.emit(action, { room: `whiteboard:${sessionId}`, user_id: targetId });
                    } else {
                        socket.emit(action, payload);
                    }

                    // If server doesn't respond by emitting permissions_updated, restore button after a short timeout
                    setTimeout(() => { try { btn.disabled = false; btn.innerHTML = prevHtml; } catch (e) {} }, 3000);
                });
            });
        }

        function updatePermissionUI() {
            if(!document.getElementById('permissionStatus')) return;
            const statusParts = [];
            statusParts.push(canDraw ? 'Draw: ✓' : 'Draw: ✕');
            statusParts.push(canSpeak ? 'Speak: ✓' : 'Speak: ✕');
            statusParts.push(canShareScreen ? 'Share: ✓' : 'Share: ✕');
            document.getElementById('permissionStatus').textContent = statusParts.join(' • ');
            document.getElementById('canvasOverlay').style.display = canDraw ? 'none' : 'flex';
            // ensure media buttons reflect current permissions
            const muteBtn = document.getElementById('muteBtn');
            const screenShareBtn = document.getElementById('screenShareBtn');
            if (muteBtn) muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
            if (screenShareBtn) screenShareBtn.disabled = !isInCall || !canShareScreen;
        }
        
        socket.on('connect', () => socket.emit('join_room', { room: `whiteboard:${sessionId}`, user_id: userId }));
        socket.on('user_joined', (data) => {
            const p = data.profile;
            if (p && !participants[p.id]) {
                participants[p.id] = { name: p.full_name || p.username, avatar_url: p.avatar_url };
                renderParticipants();
            }
        });
        socket.on('user_left', (data) => {
            delete participants[data.user_id];
            renderParticipants();
        });
        socket.on('draw_update', (data) => {
            if (!data || !data.drawing_data) return;
            const d = data.drawing_data;
            let x0 = d.x0, y0 = d.y0, x1 = d.x1, y1 = d.y1;
            if (d.normalized) {
                x0 = d.x0 * canvas.clientWidth;
                y0 = d.y0 * canvas.clientHeight;
                x1 = d.x1 * canvas.clientWidth;
                y1 = d.y1 * canvas.clientHeight;
            }
            draw(x0, y0, x1, y1, d.color, d.size, d.opacity);
        });
        socket.on('board_cleared', () => ctx.clearRect(0, 0, canvas.width, canvas.height));
        socket.on('session_ended', async (data) => {
            await leaveCall();
            showCustomAlert(data.reason || 'This session has been ended', 'Session Ended').then(() => window.location.href = '/whiteboard');
        });
        socket.on('session_warning', (data) => showCustomAlert(`This session will end in ${data.minutes_remaining} minutes.`, 'Session Warning'));
        
        socket.on('permissions_updated', (data) => {
            Object.keys(participants).forEach(uid => {
                participants[uid].can_draw = data.can_draw?.map(String).includes(String(uid));
                participants[uid].can_speak = data.can_speak?.map(String).includes(String(uid));
                participants[uid].can_share_screen = data.can_share_screen?.map(String).includes(String(uid));
            });
            const prevCanSpeak = canSpeak;
            canDraw = isCreator || data.can_draw?.map(String).includes(userId);
            canSpeak = isCreator || data.can_speak?.map(String).includes(userId);
            canShareScreen = isCreator || data.can_share_screen?.map(String).includes(userId);
            
            updatePermissionUI();
            
            if (isInCall) {
                const muteBtn = document.getElementById('muteBtn');
                const screenShareBtn = document.getElementById('screenShareBtn');
                if (muteBtn) muteBtn.disabled = !isInCall || (isMuted && !canSpeak);
                if (screenShareBtn) screenShareBtn.disabled = !canShareScreen;
                if(!canSpeak && !isMuted) {
                    try { mediaService.publishAudio(false); } catch(e) { console.warn('Could not mute after permission update', e); }
                    isMuted = true;
                    // mark that moderator forced this mute so we can auto-unmute if permissions return
                    mutedByModerator = true;
                    updateMuteButton();
                }
                // If moderator restored speak permission and we were muted by moderator, try to auto-unmute
                if (canSpeak && mutedByModerator && isMuted) {
                    console.debug('Permissions restored: attempting to auto-unmute since mute was moderator-forced');
                    try { mediaService.publishAudio(true).catch(() => {}); } catch (e) { console.warn('Auto-unmute failed', e); }
                    isMuted = false;
                    mutedByModerator = false;
                    updateMuteButton();
                    try { showCustomAlert('Your microphone was unmuted because speak permission was restored.', 'Permission'); } catch(e){}
                }
                if(!canShareScreen && isScreenSharing) {
                    try { mediaService.publishScreenShare(false); } catch(e) { console.warn('Could not stop screen share after permission update', e); }
                    isScreenSharing = false;
                    updateScreenShareButton();
                }
            }
            renderParticipants();
        });

        // Server-initiated forced actions (immediate effects)
        socket.on('force_mute', (data) => {
            // Ask the media service to stop publishing immediately
            try {
                if (isInCall) {
                    mediaService.publishAudio(false).catch(() => {});
                    isMuted = true;
                    updateMuteButton();
                }
            } catch (e) { console.warn('force_mute handling failed', e); }
            try { showCustomAlert(data?.reason || 'You have been muted by the moderator.', 'Muted'); } catch(e){}
        });

        socket.on('force_stop_screen', (data) => {
            try {
                if (isInCall && isScreenSharing) {
                    mediaService.publishScreenShare(false).catch(() => {});
                    isScreenSharing = false;
                    updateScreenShareButton();
                }
            } catch (e) { console.warn('force_stop_screen handling failed', e); }
            try { showCustomAlert(data?.reason || 'Screen sharing disabled by moderator.', 'Screen Share'); } catch(e){}
        });
        
        socket.on('hand_raised', (data) => {
            if(participants[data.user_id]) {
                participants[data.user_id].raised = true;
                renderParticipants();
            }
        });
        socket.on('hand_cleared', (data) => {
             if(participants[data.user_id]) {
                participants[data.user_id].raised = false;
                renderParticipants();
            }
        });

        // Simplified drawing logic
        const initDrawing = () => {
             if (!canvas) return;
            // Set canvas backing store to device pixel ratio for crisp lines
            setCanvasSize();
            window.addEventListener('resize', setCanvasSize);
             if (document.getElementById('brushSize')) {
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    document.getElementById('sizeValue').textContent = e.target.value;
                });
            }
             canvas.addEventListener('mousedown', (e) => { if (canDraw) { isDrawing = true; const p = getPos(e.clientX, e.clientY); lastX = p.x; lastY = p.y; } });
             canvas.addEventListener('mousemove', (e) => { if (isDrawing && canDraw) { const p = getPos(e.clientX, e.clientY); draw(lastX, lastY, p.x, p.y); emitDraw(lastX, lastY, p.x, p.y); lastX = p.x; lastY = p.y; } });
             canvas.addEventListener('mouseup', () => isDrawing = false);
             canvas.addEventListener('mouseleave', () => isDrawing = false);
             canvas.addEventListener('touchstart', (e) => { if (canDraw) { e.preventDefault(); isDrawing = true; const t = e.touches[0]; const p = getPos(t.clientX, t.clientY); lastX = p.x; lastY = p.y; } }, { passive: false });
             canvas.addEventListener('touchmove', (e) => { if (isDrawing && canDraw) { e.preventDefault(); const t = e.touches[0]; const p = getPos(t.clientX, t.clientY); draw(lastX, lastY, p.x, p.y); emitDraw(lastX, lastY, p.x, p.y); lastX = p.x; lastY = p.y; } }, { passive: false });
             canvas.addEventListener('touchend', () => isDrawing = false);
             document.getElementById('clearBtn')?.addEventListener('click', () => {
                 if (confirm('Clear the entire whiteboard?')) {
                    // Clear using CSS-size aware coordinates
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                     socket.emit('clear_board', { room: `whiteboard:${sessionId}`, user_id: userId });
                 }
             });
        };

        // --- Drawing helpers (position conversion, draw, emit) ---
        function getPos(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            // Use CSS pixels for coordinates; the context is scaled to devicePixelRatio
            return { x: (clientX - rect.left), y: (clientY - rect.top) };
        }

        // Ensure canvas has appropriate backing store size for sharp drawing
        function setCanvasSize() {
            if (!canvas || !ctx) return;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const w = Math.round(rect.width * dpr);
            const h = Math.round(rect.height * dpr);
            // Avoid unnecessary resizing which can clear the canvas
            if (canvas.width !== w || canvas.height !== h) {
                // Reset any transforms and set to a scale matching device pixel ratio
                canvas.width = w;
                canvas.height = h;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }

        function draw(x0, y0, x1, y1, color, size, opacity) {
            if (!ctx) return;
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = (typeof opacity === 'number') ? opacity : (document.getElementById('opacity')?.value || 1);
            ctx.strokeStyle = color || document.getElementById('colorPicker')?.value || '#000';
            ctx.lineWidth = size || (document.getElementById('brushSize')?.value || 3);
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        }

        function emitDraw(x0, y0, x1, y1) {
            if (!socket || !sessionId) return;
            const color = document.getElementById('colorPicker')?.value || '#000';
            const size = parseInt(document.getElementById('brushSize')?.value || '3', 10);
            const opacity = parseFloat(document.getElementById('opacity')?.value || '1');
            // Send normalized coordinates so remote clients can map to their canvas size
            const drawing_data = { x0: x0 / canvas.clientWidth, y0: y0 / canvas.clientHeight, x1: x1 / canvas.clientWidth, y1: y1 / canvas.clientHeight, color, size, opacity, normalized: true };
            socket.emit('whiteboard_draw', { room: `whiteboard:${sessionId}`, drawing_data, user_id: userId });
        }
        
        // Initial setup
        initDrawing();
        loadSessionInfo();

        // --- Landing view: Create / Join session handlers ---
        const createSessionBtnLanding = document.getElementById('createSessionBtnLanding');
        const joinSessionBtnLanding = document.getElementById('joinSessionBtnLanding');
        const createSessionModalEl = document.getElementById('createSessionModal');
        const joinSessionModalEl = document.getElementById('joinSessionModal');
        const createSessionSubmit = document.getElementById('createSessionSubmit');
        const joinSessionSubmit = document.getElementById('joinSessionSubmit');
        const sessionGroupSelect = document.getElementById('sessionGroupSelect');
        const sessionNameInput = document.getElementById('sessionNameInput');
        const createdSessionLink = document.getElementById('createdSessionLink');
        const sessionCreatedModalEl = document.getElementById('sessionCreatedModal');
        const goToSessionBtn = document.getElementById('goToSessionBtn');

        async function populateGroupSelect() {
            if (!sessionGroupSelect) return;
            sessionGroupSelect.innerHTML = '<option value="">Loading groups...</option>';
            try {
                const res = await fetch('/api/groups', { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) throw new Error('Failed to load groups');
                const data = await res.json();
                const groups = (data.data && data.data.groups) || data.groups || [];
                sessionGroupSelect.innerHTML = '';
                const myGroups = groups.filter(g => g.is_member);
                if (myGroups.length === 0) {
                    sessionGroupSelect.innerHTML = '<option value="">No groups available</option>';
                    sessionGroupSelect.disabled = true;
                    createSessionSubmit.disabled = true;
                    return;
                }
                myGroups.forEach(g => {
                    const opt = document.createElement('option');
                    opt.value = g.id || g._id;
                    opt.textContent = g.name || g.title || (`Group ${opt.value}`);
                    sessionGroupSelect.appendChild(opt);
                });
                sessionGroupSelect.disabled = false;
                createSessionSubmit.disabled = false;
            } catch (e) {
                console.error('Could not load groups:', e);
                sessionGroupSelect.innerHTML = '<option value="">Failed to load groups</option>';
                sessionGroupSelect.disabled = true;
                createSessionSubmit.disabled = true;
            }
        }

        createSessionBtnLanding?.addEventListener('click', async () => {
            await populateGroupSelect();
            try { new bootstrap.Modal(createSessionModalEl).show(); } catch(e){ createSessionModalEl.style.display='block'; }
        });

        joinSessionBtnLanding?.addEventListener('click', () => {
            try { new bootstrap.Modal(joinSessionModalEl).show(); } catch(e){ joinSessionModalEl.style.display='block'; }
        });

        createSessionSubmit?.addEventListener('click', async () => {
            const gid = sessionGroupSelect?.value;
            const title = sessionNameInput?.value || '';
            if (!gid) return alert('Please select a group to create this session for.');
            createSessionSubmit.disabled = true;
            createSessionSubmit.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating...';
            try {
                const res = await fetch(`/api/groups/${gid}/whiteboards`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify({ title })
                });
                const body = await res.json();
                if (!res.ok) throw new Error(body.message || 'Failed to create session');
                const invite = (body.data && body.data.invite_url) || body.invite_url || '/whiteboard';
                createdSessionLink.value = invite.startsWith('http') ? invite : (window.location.origin + invite);
                try { new bootstrap.Modal(sessionCreatedModalEl).show(); } catch(e){ sessionCreatedModalEl.style.display='block'; }
                // refresh the session list on landing so user sees the created session
                try { loadMySessions(); } catch(e){}
            } catch (e) {
                console.error('Create session failed:', e);
                alert(e.message || 'Could not create session');
            } finally {
                createSessionSubmit.disabled = false;
                createSessionSubmit.innerHTML = 'Create Session';
            }
        });

        goToSessionBtn?.addEventListener('click', () => {
            const url = createdSessionLink?.value;
            if (url) window.location.href = url;
        });

        joinSessionSubmit?.addEventListener('click', () => {
            const val = document.getElementById('joinSessionId')?.value?.trim();
            if (!val) return alert('Please enter a session ID or link');
            let id = val;
            try {
                // If it's a full URL with session param
                const u = new URL(val, window.location.origin);
                const s = new URLSearchParams(u.search).get('session');
                if (s) id = s;
            } catch (e) {
                // ignore
            }
            window.location.href = `/whiteboard?session=${encodeURIComponent(id)}`;
        });
        
        // --- My sessions listing and session end helper ---
        async function loadMySessions() {
            const listEl = document.getElementById('mySessionsListLanding');
            const cardEl = document.getElementById('mySessionsCardLanding');
            if (!listEl || !cardEl) return;
            listEl.innerHTML = '<div class="list-group-item">Loading...</div>';
            try {
                const res = await fetch('/api/whiteboards/mine', { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) throw new Error('Failed to fetch sessions');
                const body = await res.json();
                const sessions = (body.data && body.data.whiteboards) || [];
                if (!sessions.length) {
                    cardEl.style.display = 'none';
                    return;
                }
                cardEl.style.display = 'block';
                listEl.innerHTML = '';
                sessions.forEach(wb => {
                    const li = document.createElement('div');
                    li.className = 'list-group-item d-flex justify-content-between align-items-center';
                    li.id = `session-item-${wb.id}`;
                    const title = wb.title || 'Untitled Session';
                    const groupName = wb.group_name ? `<div class="small text-muted">${wb.group_name}</div>` : '';
                    li.innerHTML = `<div style="min-width:0;"><div class="fw-medium text-truncate" title="${title}">${title}</div>${groupName}</div><div class="d-flex gap-2"><a class="btn btn-sm btn-primary" href="/whiteboard?session=${wb.id}">Go</a><button class="btn btn-sm btn-danger end-session-btn">End</button></div>`;
                    const endBtn = li.querySelector('.end-session-btn');
                    endBtn.addEventListener('click', async () => {
                        if (!confirm('End session for everyone?')) return;
                        await endSession(wb.id);
                    });
                    listEl.appendChild(li);
                });
            } catch (e) {
                console.error('Could not load my sessions:', e);
                document.getElementById('mySessionsListLanding').innerHTML = '<div class="list-group-item text-muted">Could not load sessions</div>';
            }
        }

        async function endSession(id) {
            try {
                const res = await fetch(`/api/whiteboards/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
                const body = await res.json();
                if (!res.ok) throw new Error(body.message || 'Failed to end session');
                // If currently in that session, redirect to landing
                if (sessionId && sessionId === id) {
                    window.location.href = '/whiteboard';
                    return;
                }
                // Otherwise remove from list
                const el = document.getElementById(`session-item-${id}`);
                if (el) el.remove();
                // hide card if no items left
                const listEl = document.getElementById('mySessionsListLanding');
                if (listEl && listEl.children.length === 0) document.getElementById('mySessionsCardLanding').style.display = 'none';
                alert(body.message || 'Session ended');
            } catch (e) {
                console.error('Failed to end session:', e);
                alert(e.message || 'Could not end session');
            }
        }

        // --- Fullscreen handlers (mobile whiteboard + remote video) ---
        (function setupFullscreen() {
            const fsToggle = document.getElementById('fullscreenToggleBtn');
            const canvasContainerEl = document.getElementById('canvasContainer');
            const remoteFsBtn = document.getElementById('fullscreenBtn');
            const remoteContainer = document.getElementById('remoteVideoContainer');

            let _wbPrev = null;
            async function enterWhiteboardFullscreen() {
                if (!canvasContainerEl) return;
                // save previous sizing
                _wbPrev = { width: canvas.width, height: canvas.height };
                // snapshot current canvas to preserve drawing content
                let _wbSnapshot = null;
                try { _wbSnapshot = canvas.toDataURL(); } catch(e) { console.warn('Could not snapshot canvas', e); }

                // Prefer Fullscreen API
                try {
                    if (canvasContainerEl.requestFullscreen) {
                        await canvasContainerEl.requestFullscreen();
                    } else if (canvasContainerEl.webkitRequestFullscreen) {
                        canvasContainerEl.webkitRequestFullscreen();
                    } else {
                        canvasContainerEl.classList.add('whiteboard-fullscreen');
                    }
                } catch (e) {
                    // fallback to class-based fullscreen + resize
                    canvasContainerEl.classList.add('whiteboard-fullscreen');
                }
                // resize canvas to match viewport (account for devicePixelRatio)
                try {
                    const dpr = window.devicePixelRatio || 1;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.width = Math.round(window.innerWidth * dpr);
                    canvas.height = Math.round(window.innerHeight * dpr);

                    // restore snapshot scaled to new size
                    if (_wbSnapshot) {
                        const img = new Image();
                        img.onload = () => {
                            try {
                                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
                            } catch(e) { console.warn('Could not restore canvas snapshot', e); }
                        };
                        img.src = _wbSnapshot;
                    }
                } catch (e) { console.warn('Could not resize canvas for fullscreen', e); }
                // show an exit button
                let exit = document.getElementById('wb-fs-exit');
                if (!exit) {
                    exit = document.createElement('button');
                    exit.id = 'wb-fs-exit';
                    exit.className = 'btn btn-light fullscreen-exit-btn';
                    exit.innerHTML = '<i class="fas fa-times"></i>';
                    exit.addEventListener('click', exitWhiteboardFullscreen);
                    document.body.appendChild(exit);
                }
            }

            function exitWhiteboardFullscreen() {
                if (!canvasContainerEl) return;
                // snapshot current fullscreen canvas so we can restore it at previous size
                let _wbSnapshot = null;
                try { _wbSnapshot = canvas.toDataURL(); } catch(e) { console.warn('Could not snapshot canvas before exit', e); }

                canvasContainerEl.classList.remove('whiteboard-fullscreen');
                // restore canvas size
                try {
                    if (_wbPrev) {
                        const dpr = window.devicePixelRatio || 1;
                        canvas.width = _wbPrev.width;
                        canvas.height = _wbPrev.height;
                        canvas.style.width = '';
                        canvas.style.height = '';
                        _wbPrev = null;

                        // restore snapshot scaled back to previous size
                        if (_wbSnapshot) {
                            const img = new Image();
                            img.onload = () => {
                                try {
                                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
                                } catch(e) { console.warn('Could not restore canvas snapshot on exit', e); }
                            };
                            img.src = _wbSnapshot;
                        }
                    }
                } catch (e) { console.warn('Could not restore canvas size', e); }
                const exit = document.getElementById('wb-fs-exit');
                if (exit) exit.remove();
            }

            if (fsToggle) {
                fsToggle.addEventListener('click', () => {
                    if (canvasContainerEl.classList.contains('whiteboard-fullscreen')) exitWhiteboardFullscreen();
                    else enterWhiteboardFullscreen();
                    // adjust canvas size to fill
                    try { canvas.style.width = '100%'; canvas.style.height = '100%'; } catch(e){}
                });
            }

            if (remoteFsBtn && remoteContainer) {
                remoteFsBtn.addEventListener('click', async () => {
                    try {
                        if (document.fullscreenElement) await document.exitFullscreen();
                        else await remoteContainer.requestFullscreen();
                    } catch (e) {
                        console.warn('Fullscreen API failed, fallback toggling class');
                        remoteContainer.classList.toggle('whiteboard-fullscreen');
                    }
                });
            }
        })();
        
    })();
</script>
{% endblock %}